--- 
name: lamdas-vs-closures
layout: post
title: Lamdas vs. Closures
time: 2010-07-13 23:21:00 +01:00
---
When writing Java in a functional style, apart from the verbosity of it all, it always bugged me about the terminology we use. I tend to talk about closure-like arguments but revisiting some old University materials when clearing out the loft, I've adjusted my vocabulary somewhat. Taking the <span style="font-family: &quot;Courier New&quot;,Courier,monospace; font-size: x-small;">WaitFor</span> class from t<a href="http://code.google.com/p/tempus-fugit/">empus-fugit</a> as an example, passing an anonymous class instance as a parameter to a method that will later call the instance is a kind of functional programming. I say kind-of because its not really functional programming, Java isn't a functional language but we can bend it into a style that's similar. For example,<br /><br /><pre class="brush: java;" name="code">...<br />server.start();<br />waitOrTimeout(new Condition() {<br />   @Override<br />   public boolean isSatisfied() {<br />      return server.isRunning();<br />   }<br />}, timeout(seconds(5)));<br /></pre><br />The anonymous class implementing <span style="font-family: &quot;Courier New&quot;,Courier,monospace; font-size: x-small;">Condition</span> is evaluated by the method <span style="font-family: &quot;Courier New&quot;,Courier,monospace; font-size: x-small;">waitOrTimeout</span> (it's that which will call the <span style="font-family: &quot;Courier New&quot;,Courier,monospace; font-size: x-small;">isSatisfied</span>) method.<br /><br />The recent shift to this functional style has lead to eager anticipation of JDK7 and the promise of closures. More accurately however, it's the inclusion of lamdas that we're waiting for, not closures. Closures have in fact been available in Java since 1.1, so what's the difference?<br /><br /><h3>Lambs to the Slaughter</h3><br />So, we want to be able to define anonymous functions on the fly, the result of the function is purely dependent on it's arguments and this is called a lamda. Those functions that depend on external values (not just it's arguments) are when closures come into it. The act of binding those external values to the anonymous function is referred to as <i>closure</i>. After closure, when all variables have been captured and bound to the function, the term is closed.<br /><br />For example, the code snippet above will return a new <span style="font-family: &quot;Courier New&quot;,Courier,monospace; font-size: x-small;">Condition</span> instance on each invocation. Because it will bind the variable server to the anonymous function, it will return a closure. To put it another way, we'll extract the anonymous part to a method to explicitly create a new instance, such<br /><br /><pre class="brush: java;" name="code">private static Condition isRunning(final Server server) {<br />   return new Condition() {<br />      @Override<br />      public boolean isSatisfied() {<br />         return server.isRunning();<br />      }<br />   };<br />}<br /></pre><br />This should make it more obvious that the variable outside the scope of the anonymous <span style="font-family: &quot;Courier New&quot;,Courier,monospace; font-size: x-small;">Condition</span> is required (the <span style="font-family: &quot;Courier New&quot;,Courier,monospace; font-size: x-small;">server</span> variable), each call to the <span style="font-family: &quot;Courier New&quot;,Courier,monospace; font-size: x-small;">isRunning</span> method will return a closure over the argument, the instance of which captures the value of <span style="font-family: &quot;Courier New&quot;,Courier,monospace; font-size: x-small;">server</span>. Java implements the closure by passing a reference to the outer scoped (lets say <span style="font-size: x-small;"><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">Foo.class</span></span>) to the anonymous class (<span style="font-family: &quot;Courier New&quot;,Courier,monospace; font-size: x-small;">Foo$1.class</span>). The <span style="font-family: &quot;Courier New&quot;,Courier,monospace; font-size: x-small;">access$000</span> call accesses the appropriate private field in the outer class directly in the bytecode<br /><br /><pre class="brush: java;" name="code">class Foo$1 implements Condition {<br /><br />    final Foo this$0;<br /><br />    Foo$1() {<br />        this$0 = Foo.this;<br />        super();<br />    }<br /><br />    public boolean isSatisfied() {<br />        return Foo.access$000(Foo.this).isRunning();<br />    }<br />}<br /></pre><br />So, if, we have update the example again, this time removing the out of scope variable, we're left with something like this;<br /><br /><pre class="brush: java;" name="code">private static Condition isRunning() {<br />   return new Condition() {<br />      @Override<br />      public boolean isSatisfied() {<br />         return true; // optimistic!<br />      };<br />   }<br />}<br /></pre><br />Then no out of scope variables are required, the term doesn't need to be closed. The anonymous function that is left is effectively a lamda.<br /><br />What JDK7 will (finger's crossed) bring is more explicit, concise way of expressing the same ideas. It will support lamdas as a language feature although I can't quite figure out what the example would look like in those terms. See the <a href="http://cr.openjdk.java.net/%7Emr/lambda/straw-man/">straw man proposal</a> and see if you can figure it out!<br /><br /><div><img alt="" border="0" id="BLOGGER_PHOTO_ID_5283328307719135378" src="http://4.bp.blogspot.com/_-uMxV_fCbC4/SVInGoVdYJI/AAAAAAAAC08/I4RV1KzCyPo/s320/gibble_22x22.png" style="cursor: pointer; float: left; height: 22px; margin: 0pt 10px 10px 0pt; width: 22px;" /></div><div class="blogger-post-footer"><img width='1' height='1' src='https://blogger.googleusercontent.com/tracker/20485368-6021241204130039426?l=pequenoperro.blogspot.com' alt='' /></div>

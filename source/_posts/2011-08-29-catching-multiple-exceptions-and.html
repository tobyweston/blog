--- 
name: catching-multiple-exceptions-and
layout: post
title: Catching Multiple Exceptions (and rethrowing them all!)
time: 2011-08-29 13:09:00 +01:00
---
Sometimes, we may want to catch an exception, temporarily ignoring it to continue work before rethrowing it when its more appropriate to do so. I recently saw a slight variation of this whereby the developer wanted to (potentially) catch multiple exceptions, perform some processing then throw. However, it left the question that if more than one was caught, which exception should we actually rethrow. We certainly don't want to loose any information and should really allow the client to catch the exception in a standard way.<br /><br />This got me thinking about how we should deal with this kind of thing. In the end, I came up with the idea of a collection class to capture the <code>Exceptions</code> and a sub-class of <code>Exception</code> to represent an exception containing other, embedded exceptions. When you're done collecting exceptions, you can just check and rethrow as a new exception type.<br /><br /><a name='more'></a><br />For example, the domain cleaning class below can throw an exception during the <code>deleteAll</code> method. Rather than abandon the cleanup of subsequent objects, we can employ this tactic to continue the cleanup and throw an exception containing the underlying problems when we're done.<br /><br /><pre class="java:nogutter:nocontrols" name="code">public class DomainCleaner {
<br /> 
<br />    public static void clean(Domain domain) throws CompositeException {
<br />        Exceptions exceptions = new Exceptions();
<br />        clean(domain.customers(), exceptions);
<br />        clean(domain.suppliers(), exceptions);
<br />        clean(domain.invoices(), exceptions);
<br />        exceptions.checkAndThrow();
<br />    }
<br /> 
<br />    private static void clean(Repository repository, Exceptions exceptions) {
<br />        try {
<br />            ((TestRepository) repository).deleteAll();
<br />        } catch (RepositoryException e) {
<br />            exceptions.add(e);
<br />        }
<br />    }
<br />}
<br /></pre>We simply add to the exception collection class (<code>exceptions.add(e)</code>) and then when we're done, we can check it and throw a composite exception if needed with <code>exceptions.checkAndThrow()</code>.<br /><br />So far, we've only been interested in the fact that multiple exception can be handled and so haven't needed to programmatically query for specific exception types. For example, we've only needed this up until now.<br /><br /><pre class="java:nogutter:nocontrols" name="code">try {
<br />   // ... something that calls checkAndThrow()
<br />} catch (CompositeException e) {
<br />   // ... this is enough for now
<br />}
<br /></pre><br />The details of the classes are below. <br /><br /><pre class="java:nogutter:nocontrols" name="code">public class Exceptions implements java.lang.Iterable&lt;Exception&gt; {
<br />
<br />    private final List&lt;Exception&gt; exceptions = new ArrayList&lt;Exception&gt;();
<br />
<br />    public void add(Exception exception) {
<br />        exceptions.add(exception);
<br />    }
<br />
<br />    @Override
<br />    public Iterator&lt;Exception&gt; iterator() {
<br />        return exceptions.iterator();
<br />    }
<br />
<br />    public void checkAndThrow() throws CompositeException {
<br />        if (!exceptions.isEmpty())
<br />            throw new CompositeException(this);
<br />    }
<br />}</pre><br />The <code>toString()</code> implementation below outputs the embedded exceptions in a way that is consistent with how you'd expect to see regular exceptions.<br /><br /><pre class="java:nogutter:nocontrols" name="code">public class CompositeException extends Exception {
<br />
<br />    private final Exceptions exceptions;
<br />
<br />    public CompositeException(Exceptions exceptions) {
<br />        super("composite exception was thrown with embedded exceptions (see details)");
<br />        this.exceptions = exceptions;
<br />    }
<br />
<br />    @Override
<br />    public String toString() {
<br />        StringBuilder builder = new StringBuilder();
<br />        for (Exception exception : exceptions)
<br />            builder.append('\t').append(new ExceptionToString(exception).toString()).append('\n');
<br />        return String.format("%s\n{composite exceptions=\n%s}\n%s", this.getClass().getName(), builder.toString(), super.toString());
<br />    }
<br />}
<br /></pre><br /><br /><div><img alt="" border="0" id="BLOGGER_PHOTO_ID_5283328307719135378" src="http://4.bp.blogspot.com/_-uMxV_fCbC4/SVInGoVdYJI/AAAAAAAAC08/I4RV1KzCyPo/s320/gibble_22x22.png" style="cursor: pointer; float: left; height: 22px; margin: 0pt 10px 10px 0pt; width: 22px;" /></div></div></div><div class="blogger-post-footer"><img width='1' height='1' src='https://blogger.googleusercontent.com/tracker/20485368-7358500814296965448?l=pequenoperro.blogspot.com' alt='' /></div>

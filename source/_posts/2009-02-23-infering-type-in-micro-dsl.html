--- 
name: infering-type-in-micro-dsl
layout: post
title: Infering the Type in a Micro DSL
time: 2009-02-23 19:34:00 +00:00
---
In a recent <a href="http://pequenoperro.blogspot.com/2009/02/more-on-micro-dsls.html">post</a>, I was talking about a micro DSL to create a simple "find <span style="font-style: italic;">x</span> in a list" service. The key thing here is that it defines how to look for <span style="font-style: italic;">x</span> in the list. So the list can be a list of anything, not just a list of <span style="font-style: italic;">x</span>'s.<br /><br />Just to recap then, to find something in a list, the original client code (using a static import) looks like this.<br /><pre name="code" class="java:nogutter:nocontrols"><br />find(needle).in(haystack)<br /></pre><br />The class (in this case <span style="font-size:85%;"><span style="font-family:courier new;">NeedleFinder</span></span>) implements the DSL and specifically decides in the in method how to compare a <span style="font-size:85%;"><span style="font-family:courier new;">Needle</span></span> object to whatever is in the <span style="font-size:85%;"><span style="font-family:courier new;">haystack</span></span> list. I wanted to create a more generic class so started to implement the <span style="font-size:85%;"><span style="font-family:courier new;">ListFinder</span></span> to use generics and a couple of interesting things came out.<br /><br />The generified class looks like this.<br /><pre name="code" class="java:nogutter:nocontrols"><br />public final class ListFinder&lt;T, L&gt; {<br /> private final T target;<br /> private List&lt;L&gt; list = new ArrayList&lt;L&gt;();<br /><br /> private ListFinder(T target) {<br />    this.target = target;<br /> }<br /><br /> public static &lt;T, L&gt; ListFinder&lt;T, L&gt; find(T target) {<br />    return new ListFinder&lt;T, L&gt;(target);<br /> }<br /><br /> public ListFinder&lt;T, L&gt; in(List&lt;L&gt; list) {<br />    this.list = new ArrayList&lt;L&gt;(list);<br />    return this;<br /> }<br /><br /> public L using(Comparator&lt;T, L&gt; comparator) {<br />    for (L item : list) {<br />       if (comparator.equals(target, item)) {<br />          return item;<br />       }<br />    }<br />    return null;<br /> }<br /><br /> public interface Comparator&lt;T, L&gt; {<br />    boolean equals(T target, L item);<br /> }<br /><br />}<br /></pre><br />With the following test case showing its usage (the Needle and Bale class aren't show for brevity).<br /><pre name="code" class="java:nogutter:nocontrols"><br />public class ListFinderTest {<br /><br /> private final Needle needle = new Needle("Bob");<br /> private final Needle missing = new Needle("Billy");<br /> private final Bale bale1 = new Bale("Christian");<br /> private final Bale bale2 = new Bale("Bob in disguise");<br /> private final Bale bale3 = new Bale("Kelly");<br /> private final List&lt;Bale&gt; haystack = asList(bale1, bale2, bale3);<br /><br /> private final ListFinder.Comparator&lt;Needle, Bale&gt; comparator = new ListFinder.Comparator&lt;Needle, Bale&gt;() {<br />    @Override<br />    public boolean equals(Needle needle, Bale bale) {<br />       return bale.name.contains(needle.name);<br />    }<br /> };<br /><br /> @Test<br /> public void needleFoundInHaystack() throws Exception {<br />    assertThat(find(needle).in(haystack).using(comparator), is(bale));<br /> }<br /><br /> @Test<br /> public void needleNotFoundInHaystack() throws Exception {<br />    assertThat(find(missing).in(haystack).using(comparator), is(nullValue()));<br /> }<br /><br /> private static ListFinder&lt;Needle, Bale&gt; find(Needle value) {<br />    return ListFinder.find(value);<br /> }<br />}<br /></pre><br />Here we're defining the equality of a <span style="font-size:85%;"><span style="font-family:courier new;">Needle</span></span> in a list of <span style="font-size:85%;"><span style="font-family:courier new;">Bale</span></span> objects to be when the name of a <span style="font-size:85%;"><span style="font-family:courier new;">Needle</span></span> is contained in the name of the <span style="font-size:85%;"><span style="font-family:courier new;">Bale</span></span>. A silly example I know but it illustrates that we redefine what we mean by equality for the list finder by implementing the <span style="font-size:85%;"><span style="font-family:courier new;">ListFinder.Comparator</span></span>. The concrete example that spawned the idea was when searching for a <span style="font-size:85%;"><span style="font-family:courier new;">Race</span></span> object inside a list of <span style="font-size:85%;"><span style="font-family:courier new;">Event</span></span> objects; two completely different entities.<br /><br />Anyway, what I thought was interesting about this example was the type inference going on in the static <span style="font-style: italic;">find</span> method. I originally wanted to just use <span style="font-size:85%;"><span style="font-family:courier new;">ListFinder.find</span></span> method directly as in the following.<br /><pre name="code" class="java:nogutter:nocontrols"><br />ListFinder.find(needle).in(haystack).using(comparator)<br /></pre><br />Where <span style="font-size:85%;"><span style="font-family:courier new;">ListFinder</span></span> is statically imported. Usually, I'd rely on type inference here to work out that <span style="font-size:85%;"><span style="font-family:courier new;">needle</span></span> means <span style="font-size:85%;"><span style="font-family:courier new;">T</span></span> and therefore <span style="font-size:85%;"><span style="font-family:courier new;">T</span></span> is of type <span style="font-size:85%;"><span style="font-family:courier new;">Needle</span></span>. However, in the case above, the compiler will complain as the <span style="font-size:85%;"><span style="font-family:courier new;">haystack</span></span> parameter is not of type <span style="font-size:85%;"><span style="font-family:courier new;">Object</span></span>. The trick is that the generic method <span style="font-size:85%;"><span style="font-family:courier new;">find</span></span> in <span style="font-size:85%;"><span style="font-family:courier new;">ListFinder</span></span> needs to infer <span style="font-weight: bold; font-style: italic;">two </span>types (<span style="font-size:85%;"><span style="font-family:courier new;">T</span></span> and <span style="font-size:85%;"><span style="font-family:courier new;">L</span></span>) but only has enough information for <span style="font-size:85%;"><span style="font-family:courier new;">T</span></span>. So it defaults <span style="font-size:85%;"><span style="font-family:courier new;">L</span></span> to type <span style="font-size:85%;"><span style="font-family:courier new;">Object</span></span>. grrr damn Java indisputable logic.<br /><br />The alternative is to use the full notation as follows.<br /><pre name="code" class="java:nogutter:nocontrols"><br />ListFinder.&lt;Needle, Bale&gt;find(needle).in(haystack).using(comparator)</pre><br />Or (as I've done in the test) use an internal method who's return type gives the compiler enough information to infer both types. I prefer this approach as it makes the DSL expression to find a needle much more readable.<br /><br />So, Java can't chain methods to infer the types. I didn't really expect it to be able to so, its a bit much to ask for. Although it would be pretty sweet if it could.<br /><br />One last thing, <a href="http://codewax.blogspot.com/">Papa Ray</a> was showing me a <a href="http://docs.codehaus.org/display/JEDI/Home">Jedi</a> alternative to the finder. If we're lucky, he might blog about it. It seems Jedi offers some measure of insurgency against the proliferation of anonymous inner classes in lieu of closures but in all honestly, I just wanted to get in some big words in before signing off. TTFN.<br /><div><br /></div><div><img src="http://4.bp.blogspot.com/_-uMxV_fCbC4/SVInGoVdYJI/AAAAAAAAC08/I4RV1KzCyPo/s320/gibble_22x22.png" alt="" id="BLOGGER_PHOTO_ID_5283328307719135378" style="margin: 0pt 10px 10px 0pt; float: left; cursor: pointer; width: 22px; height: 22px;" border="0" /></div><div><br /></div><div class="blogger-post-footer"><img width='1' height='1' src='https://blogger.googleusercontent.com/tracker/20485368-6249446553913436277?l=pequenoperro.blogspot.com' alt='' /></div>

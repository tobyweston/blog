--- 
name: previwed
layout: post
title: JDK7 Previwed
time: 2011-03-04 15:44:00 +00:00
---
Oracle put out the preview release of JDK7 last month. I guess they felt they had to. So, it's not what was once heralded (will <a href="http://openjdk.java.net/projects/lambda/">8 see lamdas</a>?) but still has one or two interesting language features. The ones that caught my eye include;<br /><br /><h3>Type Inference on Generic Object Creation</h3><br />Which allows a little brevity to the garrulity of the language, at least against generic object instantionation where the type can be infered. For example,<br /><pre class="brush: java;" name="code">private Map&lt;Size, List&lt;Shoe&gt;&gt; stock = new HashMap&lt;Size, List&lt;Shoe&gt;&gt;();
<br /></pre>can be reduced to <br /><pre class="brush: java;" name="code">private Map&lt;Size, List&lt;Shoe&gt;&gt; stock = new HashMap&lt;&gt;();
<br /></pre><br />where the <i>diamond operator</i> can be filled in or inferred from the declaration. It's subtly different than leaving out the generic completely which will reduce your type to being of <code>Object</code> Things don't get much better than this.<br /><br />Actually, it does. Just a little. Constructor generics always used to be fun and that hasn't really changed, although with JDK7 you can do a little more. For example,<br /><br /><a name='more'></a><br /><pre class="brush: java;" name="code">public class Bob&lt;Y&gt; {
<br />    public &lt;T&gt; Bob(T t) {
<br />    }
<br />
<br />    public void example() {
<br />        Bob&lt;Integer&gt; bob = new Bob&lt;&gt;("yum");
<br />    }
<br />
<br />    public void anotherExample() {
<br />        Bob&lt;Integer&gt; bob = new &lt;String&gt; Bob&lt;&gt;("yum");
<br />    }
<br />}
<br /></pre>The examples are the same as the one Oracle gives, they both work with JDK7 only and show the <code>Integer</code> type inferred as the class generic (<code>Y</code>) in combination with the diamond operator. The second example shows new syntax to explicitly set type of the method generic and give some additional compile time checks. <br /><br /><h3>try-with-resource and <code>AutoClosable</code></h3><br />Another bugbear with the verbosity of Java has always been the try-catch-finally syntax. The new language feature try-with-resource allows you to chop this down some what in combination with auto-closable resources. Here, rather than the familiar, try-finally to close a resource, you can "open" the resource within the parenthesis of the try statement (as long as the object implements <code>AutoCloassable</code> and the resource will always close itself in a <code>finally</code> like way.<br /><br />For example,<br /><pre class="brush: java;" name="code">private String example() throws IOException {
<br />    BufferedReader reader = new BufferedReader(...);
<br />    try {
<br />        return reader.readLine();
<br />    } finally {
<br />        reader.close();
<br />    }
<br />}
<br /></pre><br />gets replaced with<br /><pre class="brush: java;" name="code">private String example() throws IOException {
<br />    try(BufferedReader reader = new BufferedReader(...) {
<br />         return reader.readLine();
<br />    }
<br />}
<br /></pre>Dr Heinz combined this technique with a way to automatically unlock locked resources in a <a href="http://www.javaspecialists.eu/archive/Issue190.html">recent news letter</a>.<br /><br />There may be a little gotcha using this where exceptions can be suppressed and have to be retrieved using <code>Throwable.getSuppressed()</code>. This seems like it could be nasty.<br /><br /><h3>Catching Multiple Exceptions</h3><br />This one allows you to catch multiple exceptions using a pipe to separate the exception types. This looks like another work around for the general grips with Java but removes the duplicated code you often get catching several exceptions and treating them in the same way. For example, <br /><pre class="brush: java;" name="code">catch (IOException | SQLException e) {
<br />    logger.log(e);
<br />    throw ex;
<br />}
<br /></pre>I usually end up pushing the code to execute as a <code>Callable</code> and dealing with the exception in a lamda-like piece of code, or decorating the fragment to deal with exceptions (logging or wrapping) or even trying really hard to throw around runtime exceptions, so this one is at odds with my general approach. Given the example from Oracle above, I suspect this will just facilitate ugly, jammed in code. It seems to say "it's ok to deal with a bunch of exceptions in the same way. in fact, we'll make it easier for you" without any warning about if you actually <i>should</i> be doing this type of thing. The fact the example above (Oracle's example, by the way) logs then re-throws is a smell in it's self. Perhaps I'm being premenstrual, but I'm not a fan of this one.  <br /><br />Have a look <a href="http://download.java.net/jdk7/docs/#NewFeature">here</a> for on the new features and download from <a href="http://www.oracle.com/technetwork/java/javase/downloads/ea-jsp-142245.html">here</a> (unfortunately, not for the Mac).<br /><br /><span class="Apple-style-span" style="color: red;"><b>UPDATE:</b></span> An extended version of this post has been published in <a href="http://pequenoperro.blogspot.com/2011/06/jdk7-artcile-in-javatech-journal.html">May edition of the JavaTech Journal</a>.<br /><br /><div><img alt="" border="0" id="BLOGGER_PHOTO_ID_5283328307719135378" src="http://4.bp.blogspot.com/_-uMxV_fCbC4/SVInGoVdYJI/AAAAAAAAC08/I4RV1KzCyPo/s320/gibble_22x22.png" style="cursor: pointer; float: left; height: 22px; margin: 0pt 10px 10px 0pt; width: 22px;" /></div><div class="blogger-post-footer"><img width='1' height='1' src='https://blogger.googleusercontent.com/tracker/20485368-5100755803794529782?l=pequenoperro.blogspot.com' alt='' /></div>

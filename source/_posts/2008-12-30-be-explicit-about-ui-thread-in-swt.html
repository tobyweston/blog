--- 
name: be-explicit-about-ui-thread-in-swt
layout: post
title: Be Explicit with the UI Thread
time: 2008-12-30 12:00:00 +00:00
---
Following up from the post <a href="http://pequenoperro.blogspot.com/2008/12/swt-support-for-window-licker.html">SWT Support in Window Licker</a>.<br /><br />The thing I found most interesting about looking at this was having to be more explicit about the UI thread. When developing SWT applications, we're all aware that accessing almost anything graphical in SWT from any other thread than the UI thread spells "invalid thread access", but it was fun to be more explicit about the "UI thread".<br /><br />When I started to look at how I go about writing SWT applications, I noticed that<br /><ul><li>I often run the application from a <span style="font-size:85%;"><span style="font-family:courier new;">main</span></span> somewhere.</li><li>I often discover invalid thread access problems at run time.</li><li>I often plug the problem by wrapping the offender in a <span style="font-size:85%;"><span style="font-family:courier new;">Display.a/sync(...)</span></span> call.</li><li>I often have very few long running processes that need to spawn a thread and update the UI.<br /></li></ul>It wasn't until I started looking at being able to run the application from the context of a JUnit test that I started to think in more detail about these.<br /><br /><span style="font-weight: bold;">Running the application from a main method</span><br /><br />This seems simple but being more explicit about the UI thread means that this is worth a closer look. I always used to start an SWT application from the main, in variations of the code below.<br /><br /><a onblur="try {parent.deselectBloggerImageGracefully();} catch(e) {}" href="http://1.bp.blogspot.com/_-uMxV_fCbC4/SVjhnGg2niI/AAAAAAAAC2g/D-Oxt3L5Y_Q/s1600-h/swt-1.PNG"><img style="margin: 0pt 10px 10px 0pt; display: block; cursor: pointer; width: 400px; height: 317px;" src="http://1.bp.blogspot.com/_-uMxV_fCbC4/SVjhnGg2niI/AAAAAAAAC2g/D-Oxt3L5Y_Q/s400/swt-1.PNG" alt="" id="BLOGGER_PHOTO_ID_5285222224598834722" border="0" /></a><br /><br />The default constructor would do or delegate the work to setup the various shells and widgets and finally start the event loop. When using JFace's <span style="font-size:85%;"><span style="font-family:courier new;">ApplicationWindow</span></span>, I'd do pretty much the same thing. Calling <span style=";font-family:courier new;font-size:85%;"  >window.setBlockOnOpen(true)</span> just shifts the responsibility of starting the event loop to the <span style="font-size:85%;"><span style="font-family:courier new;">ApplicationWindow</span></span> class. If you call <span style=";font-family:courier new;font-size:85%;"  >window.setBlockOnOpen(false)</span> for example, you have to manually start an event loop.<br /><br />However you do it, getting into that event loop blocks the client and its the <span style="font-weight: bold;">thread that executes this event loop that is called the UI thread</span>. It just so happens that most SWT applications will hit that loop from the <span style=";font-family:courier new;font-size:85%;"  >main</span> thread as you can see from the following partial thread dump.<br /><br /><div style="border: 1px solid gray;"><br /><span style="font-size:85%;"><span style="font-family:courier new;">Name: <span style="font-weight: bold;">main</span></span><br /><span style="font-family:courier new;">State: RUNNABLE</span><br /><span style="font-family:courier new;">Total blocked: 0  Total waited: 0</span><br /><br /><span style="font-family:courier new;">Stack trace: </span><br /><span style="font-family:courier new;">org.eclipse.swt.internal.win32.OS.WaitMessage(Native Method)</span><br /><span style="font-family:courier new;">org.eclipse.swt.widgets.Display.sleep(Unknown Source)</span><br /><span style="font-family:courier new;">com.objogate...SwtCalculator.startEventLoop(SwtCalculator.java:104)</span><br /><span style="font-family:courier new;">com.objogate...SwtCalculator.main(SwtCalculator.java:113)</span></span><br /><br /></div><br />At this point, the SWT event loop is doing its thing, waiting for UI events (mouse clicks, keyboard input etc) and dispatching them to the appropriate listeners. We've also defined what we mean by the UI thread;<br /><br /><blockquote><div style="text-align: center; font-weight: bold;">The <span style="font-style: italic;">UI thread</span> or <span style="font-style: italic;">event dispatching thread</span> is the thread that executes the standard SWT event loop.</div></blockquote><br /><br /><span style="font-weight: bold;">Running the tests and GUI in different threads</span><br /><br /><span style="font-weight: bold;"></span>So, if the event loop was called from within say a <span style="font-size:85%;"><span style="font-family:courier new;">@Before</span></span> annotated method in a test, the test would block until the event loop finished, the display would be disposed and any subsequent tests against the GUI elements would quickly discover that they no longer exist.<br /><br />It should be pretty clear then that in order to test GUI elements the event loop has to be started in a different thread than the tests run in. The gotcha is that the test thread will likely want to interact with this UI thread in order to push buttons and make assertions and that's when we get into invalid thread access territory with SWT.<br /><br />The way I implemented this was to use a class extending <span style="font-size:85%;"><span style="font-family:courier new;">Thread</span></span> to represent the UI thread and to start the event loop in its <span style="font-size:85%;"><span style="font-family:courier new;">run()</span></span> method. The tests can interact with the UI thread by either searching for the display with <span style=";font-family:courier new;font-size:85%;"  >Display.findDisplay(thread)</span> or by cooperating and ensuring that only the default display is used (retrieving it using <span style="font-size:85%;"><span style="font-family:courier new;">Display.getDefault()</span></span>).<br /><br />A minor change to the application's main method is required to optionally not call the event loop when calling <span style="font-size:85%;"><span style="font-family:courier new;">main</span></span>. For example;<br /><br /><a onblur="try {parent.deselectBloggerImageGracefully();} catch(e) {}" href="http://2.bp.blogspot.com/_-uMxV_fCbC4/SVjqbgglEBI/AAAAAAAAC24/Ug_OpHH2xWw/s1600-h/swt-2.PNG"><img style="margin: 0pt 10px 10px 0pt; display: block; cursor: pointer; width: 400px; height: 80px;" src="http://2.bp.blogspot.com/_-uMxV_fCbC4/SVjqbgglEBI/AAAAAAAAC24/Ug_OpHH2xWw/s400/swt-2.PNG" alt="" id="BLOGGER_PHOTO_ID_5285231921023225874" border="0" /></a><br /><br />The tests can then explicitly  create a UI thread delegating shell setup to the <span style="font-size:85%;"><span style="font-family:courier new;">SwtCalculator</span></span> class before starting the event loop and allowing the test thread to continue.<br /><br /><div style="text-align: left;"><a onblur="try {parent.deselectBloggerImageGracefully();} catch(e) {}" href="http://3.bp.blogspot.com/_-uMxV_fCbC4/SVjrKjq6UGI/AAAAAAAAC3A/nOVZyQi0yIY/s1600-h/swt-3.PNG"><img style="margin: 0pt 10px 10px 0pt; display: block; cursor: pointer; width: 400px; height: 180px;" src="http://3.bp.blogspot.com/_-uMxV_fCbC4/SVjrKjq6UGI/AAAAAAAAC3A/nOVZyQi0yIY/s400/swt-3.PNG" alt="" id="BLOGGER_PHOTO_ID_5285232729325719650" border="0" /></a><br /><br />The <span style=";font-family:courier new;font-size:85%;"  >UISetupClosure</span> allows the setup code (in this case the <span style="font-size:85%;"><span style="font-family:courier new;">main</span></span> method) to run <span style="font-style: italic;">inside</span> the UI thread. This uses the strategy pattern but an alternative design could just as easily sub-class the <span style="font-size:85%;">UIThread</span> and use the template pattern in a similar way.<br /><br />The interrupt allows the event loop on the UI thread to be interrupted and stop gracefully.<br /><br />The following partial thread dump shows it in action. As you can see, a explicit thread has started the event loop (the <span style=";font-family:courier new;font-size:85%;"  >Display.sleep</span> and <span style=";font-family:courier new;font-size:85%;"  >WaitMessage</span> are the hints).<br /></div><br /><br /><div style="border: 1px solid gray;"><br /><span style="font-size:85%;"><span style="font-family:courier new;">Name: <span style="font-weight: bold;">SWT-Event-Dispatcher-Thread-1</span></span><br /><span style="font-family:courier new;">State: RUNNABLE</span><br /><span style="font-family:courier new;">Total blocked: 0  Total waited: 0</span><br /><br /><span style="font-family:courier new;">Stack trace: </span><br /><span style="font-family:courier new;">org.eclipse.swt.internal.win32.OS.WaitMessage(Native Method)</span><br /><span style="font-family:courier new;">org.eclipse.swt.widgets.Display.sleep(Unknown Source)</span><br /><span style="font-family:courier new;">com.objogate.wl.swt.UIThread.startEventLoop(UIThread.java:90)</span><br /><span style="font-family:courier new;">com.objogate.wl.swt.UIThread.run(UIThread.java:68)</span><br /><span style="font-family:courier new;">   - locked java.lang.Class@1d7fbfb</span></span><br /><br /></div><br />It was a good exercise exploring the UI thread and I encourage you to take a look at <a href="http://code.google.com/p/windowlicker/">Window Licker</a> (and my <a href="http://windowlicker-users.googlegroups.com/web/window-licker-swt-spike.patch">SWT patch</a>). Have a play and see if you agree with the approach I took above.<br /><br /><img src="http://4.bp.blogspot.com/_-uMxV_fCbC4/SVInGoVdYJI/AAAAAAAAC08/I4RV1KzCyPo/s320/gibble_22x22.png" style="margin: 0pt 10px 10px 0pt; float: left; cursor: pointer; width: 22px; height: 22px;" alt="" id="BLOGGER_PHOTO_ID_5283328307719135378" border="0" /><div class="blogger-post-footer"><img width='1' height='1' src='https://blogger.googleusercontent.com/tracker/20485368-5325055086578443443?l=pequenoperro.blogspot.com' alt='' /></div>

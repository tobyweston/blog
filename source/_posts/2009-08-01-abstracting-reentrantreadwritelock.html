--- 
name: abstracting-reentrantreadwritelock
layout: post
title: Abstracting ReentrantReadWriteLock
time: 2009-08-01 10:47:00 +01:00
---
All locks in Java are reentrant, they have to be in case the owner of the monitor ends up calling a method that needs that monitor. So, if a thread requests a lock that it already holds, it'll be given it. Without this, a subclass couldn't override a snynchronised method and then call the superclass method without deadlocking.<br /><br />Java's <a href="http://java.sun.com/javase/6/docs/api/java/util/concurrent/locks/ReentrantReadWriteLock.html"><span style="font-size: 85%;"><span style="font-family: courier new;">ReenstrantReadWriteLock</span></span></a> is about acquiring seperate <span style="font-style: italic; font-weight: bold;">read</span> and <span style="font-style: italic; font-weight: bold;">write</span> locks for efficiency. For example, in the case where you may have infrequent writes but frequent reads, it <i>may</i> be more efficient to not synchronise <span style="font-weight: bold;">all</span> access with just one lock. Instead, <a href="http://java.sun.com/javase/6/docs/api/java/util/concurrent/locks/ReentrantReadWriteLock.html"><span style="font-size: 85%;"><span style="font-family: courier new;">ReenstrantReadWriteLock</span></span></a> can allow all read access to only block when a write is taking place. You'll end up with multiple simultaneous reads but synchronised writes and all the reads will have guaranteed visibility of the writes.<br /><br />How to know when to actually use the <a href="http://java.sun.com/javase/6/docs/api/java/util/concurrent/locks/ReentrantReadWriteLock.html"><span style="font-size: 85%;"><span style="font-family: courier new;">ReenstrantReadWriteLock</span></span></a> is going to have to be the subject of a followup post, but as you'd expect, profiling is going help you make decisions against your specific situation.<br /><br />With all <a href="http://java.sun.com/javase/6/docs/api/java/util/concurrent/locks/Lock.html"><span style="font-size: 85%;"><span style="font-family: courier new;">Lock</span></span></a> implementations, you specifically acquire the lock and are politely asked to release the lock within a <span style="font-size: 85%;"><span style="font-family: courier new;">finally</span></span> block. Makes sense but it always bugs me that we're forced into Java's verbosity trap, yet again.<br /><br />So, vanilla Java would have you;<br /><pre class="java:nogutter:nocontrols" name="code">Lock l = ...;<br />l.lock();<br />try {<br />    // access the resource protected by this lock<br />} finally {<br />    l.unlock();<br />}<br /></pre>So why not wrap the boiler plate code up in a micro-DSL and pass a closure-like thing to execute? Any implementation must call both <span style="font-size: 85%;"><span style="font-family: courier new;">lock</span></span> and <span style="font-size: 85%;"><span style="font-family: courier new;">unlock</span></span> and re-throw any exceptions. The following test shows this to be true.<br /><pre class="java:nogutter:nocontrols" name="code">@RunWith(JMock.class)<br />public class ExecuteUsingLockTest {<br /><br />    private final Mockery context = new JUnit4Mockery() {{<br />        setImposteriser(ClassImposteriser.INSTANCE);<br />    }};<br /><br />    ReadLock readLock = context.mock(ReadLock.class);<br />    WriteLock writeLock = context.mock(WriteLock.class);<br /><br />    @Test<br />    public void readLock() {<br />        setExpectationsOn(readLock);<br />        execute(something()).using(readLock);<br />    }<br /><br />    @Test<br />    public void writeLock() {<br />        setExpectationsOn(writeLock);<br />        execute(something()).using(writeLock);<br />    }<br /><br />    @Test (expected = Exception.class)<br />    public void readLockThrowingException() throws Exception {<br />        setExpectationsOn(readLock);<br />        execute(somethingThatThrowsException()).using(readLock);<br />    }<br /><br />    @Test(expected = Exception.class)<br />    public void writeLockThrowingException() throws Exception {<br />        setExpectationsOn(writeLock);<br />        execute(somethingThatThrowsException()).using(writeLock);<br />    }<br /><br />    private Callable&lt;Void, RuntimeException&gt; something() {<br />        return new Callable&lt;Void, RuntimeException&gt;() {<br />            public Void call() throws RuntimeException {<br />                return null;<br />            }<br />        };<br />    }<br /><br />    private Callable&lt;Void, Exception&gt; somethingThatThrowsException() {<br />        return new Callable&lt;Void, Exception&gt;() {<br />            public Void call() throws Exception {<br />                throw new RuntimeException("bad robot");<br />            }<br />        };<br />    }<br /><br />    private void setExpectationsOn(final Lock lock) {<br />        context.checking(new Expectations() {{<br />            one(lock).lock();<br />            one(lock).unlock();<br />        }});<br />    }<br />}<br /></pre>The implementation is fairly straight forward with a couple of interesting points to note around generics.<br /><pre class="java:nogutter:nocontrols" name="code">public class ExecuteUsingLock&lt;T, E extends Exception&gt; {<br /><br />    private final Callable&lt;T, E&gt; callable;<br /><br />    private ExecuteUsingLock(Callable&lt;T, E&gt; callable) {<br />        this.callable = callable;<br />    }<br /><br />    public static &lt;T, E extends Exception&gt; ExecuteUsingLock&lt;T, E&gt; execute(Callable&lt;T, E&gt; callable) {<br />        return new ExecuteUsingLock&lt;T, E&gt;(callable);<br />    }<br /><br />    public T using(ReentrantReadWriteLock.WriteLock write) throws E {<br />        try {<br />            write.lock();<br />            return callable.call();<br />        } finally {<br />            write.unlock();<br />        }<br />    }<br /><br />    public T using(ReentrantReadWriteLock.ReadLock read) throws E {<br />        try {<br />            read.lock();<br />            return callable.call();<br />        } finally {<br />            read.unlock();<br />        }<br />    }  <br />}<br /></pre><br />Having the <a href="http://pequenoperro.blogspot.com/2009/02/more-on-micro-dsls.html">micro-DSL</a> pass in the generic <span style="font-size: 85%;"><span style="font-family: courier new;">Callable</span></span> on the static constructor meant that I couldn't make just the <span style="font-size: 85%;"><span style="font-family: courier new;">using</span></span> method generic and instead had to link the types by making the class definition generic. You might also notice that the <span style="font-size: 85%;"><span style="font-family: courier new;">Callable</span></span> used isn't Java's <span style="font-size: 85%;"><span style="font-family: courier new;">Callable</span></span>, as Sun saw fit not to have the <span style="font-size: 85%;"><span style="font-family: courier new;">Exception</span></span> as a generic type. By creating the new <span style="font-size: 85%;"><span style="font-family: courier new;">Callable</span></span> interface below, I was able to neaten up the <a href="http://pequenoperro.blogspot.com/2009/02/more-on-micro-dsls.html">micro-DSL</a> so that we're not forced to throw <span style="font-size: 85%;"><span style="font-family: courier new;">Exception</span></span> from a method that uses the <span style="font-size: 85%;"><span style="font-family: courier new;">ExecuteUsingLock</span></span> class. Instead, you define your closure-like function to throw <span style="font-size: 85%;"><span style="font-family: courier new;">RuntimeException</span></span>.<br /><br />A real world example might be something that updates a status probe where the variable <span style="font-size: 85%;"><span style="font-family: courier new;">lock</span></span> below is an instance of <span style="font-family: courier new; font-size: 85%;">ReentrantReadWriteLock</span>.<br /><pre class="java:nogutter:nocontrols" name="code">public void setStatus(final Status status) {<br />    execute(settingStatus(status)).using(lock.writeLock());<br />}<br /><br />public String getStatus() {<br />    return execute(gettingStatus()).using(lock.readLock());<br />}<br /><br />private Callable&lt;Void, RuntimeException&gt; settingStatus(final Status status) {<br />    return new Callable&lt;Void, RuntimeException&gt;() {<br />        public Void call() {<br />            EnclosingClass.this.status = status;<br />            return null;<br />        }<br />    };<br />}<br /><br />private Callable&lt;Status, RuntimeException&gt; gettingStatus() {<br />    return new Callable&lt;Status, RuntimeException&gt;() {<br />        public Status call() {<br />            return EnclosingClass.this.status.toString();<br />        }<br />    };<br />}<br /></pre>All this to avoid the boiler plate code! Fresh.<br /><div style="text-align: center;"><blockquote><span style="font-weight: bold;">Update:</span> Since writing this entry, I created the<a href="http://code.google.com/p/tempus-fugit/"> tempus-fugit</a> project to capture these kinds of ideas.</blockquote></div><div><br /><img alt="" border="0" id="BLOGGER_PHOTO_ID_5283328307719135378" src="http://4.bp.blogspot.com/_-uMxV_fCbC4/SVInGoVdYJI/AAAAAAAAC08/I4RV1KzCyPo/s320/gibble_22x22.png" style="cursor: pointer; float: left; height: 22px; margin: 0pt 10px 10px 0pt; width: 22px;" /></div><div class="blogger-post-footer"><img width='1' height='1' src='https://blogger.googleusercontent.com/tracker/20485368-7599448843063923415?l=pequenoperro.blogspot.com' alt='' /></div>

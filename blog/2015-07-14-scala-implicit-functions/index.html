<!DOCTYPE html><html lang="en"> <head><!-- Global Metadata --><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1"><link rel="icon" type="image/x-icon" href="/favicon.ico"><meta name="generator" content="Astro v5.17.3"><meta name="robots" content="index, follow, max-image-preview:large, max-snippet:-1, max-video-preview:-1"><!-- Canonical URL --><link rel="canonical" href="https://baddotrobot.com/blog/2015-07-14-scala-implicit-functions/"><!-- RSS Feed --><link rel="alternate" type="application/rss+xml" title="bad.robot" href="/rss.xml"><!-- Primary Meta Tags --><title>Implicit Functions in Scala</title><meta name="title" content="Implicit Functions in Scala"><meta name="description" content="Scala implicit functions convert types automatically when the compiler needs it. Learn how implicit conversion functions work and how to use them safely."><meta name="keywords" content="Scala implicit functions, implicit conversion, type conversion, Scala compiler, SAM, implicits"><!-- Open Graph / Facebook --><meta property="og:type" content="website"><meta property="og:url" content="https://baddotrobot.com/blog/2015-07-14-scala-implicit-functions/"><meta property="og:title" content="Implicit Functions in Scala"><meta property="og:description" content="Scala implicit functions convert types automatically when the compiler needs it. Learn how implicit conversion functions work and how to use them safely."><meta property="og:image" content="https://baddotrobot.com/images/heroes/java-code.jpg"><meta property="og:site_name" content="bad.robot"><!-- Twitter --><meta property="twitter:card" content="summary_large_image"><meta property="twitter:url" content="https://baddotrobot.com/blog/2015-07-14-scala-implicit-functions/"><meta property="twitter:title" content="Implicit Functions in Scala"><meta property="twitter:description" content="Scala implicit functions convert types automatically when the compiler needs it. Learn how implicit conversion functions work and how to use them safely."><meta property="twitter:image" content="https://baddotrobot.com/images/heroes/java-code.jpg"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","headline":"Implicit Functions in Scala","description":"Scala implicit functions convert types automatically when the compiler needs it. Learn how implicit conversion functions work and how to use them safely.","datePublished":"2015-07-14T00:00:00.000Z","image":"https://baddotrobot.com/images/heroes/functional-programming.jpg","url":"https://baddotrobot.com/blog/2015-07-14-scala-implicit-functions/","author":{"@type":"Person","name":"Toby Weston","url":"https://baddotrobot.com"},"publisher":{"@type":"Person","name":"bad.robot"}}</script><link rel="stylesheet" href="/_astro/index.CzF6U4o9.css">
<link rel="stylesheet" href="/_astro/_slug_.DbZHOt6G.css"></head> <body class="bg-white text-gray-900"> <header class="header" data-astro-cid-3ef6ksr2> <div class="header-container" data-astro-cid-3ef6ksr2> <div class="logo-section" data-astro-cid-3ef6ksr2> <a href="/" class="logo-link" data-astro-cid-3ef6ksr2> <img src="/_astro/robot-logo_105x132.N1ZQY9mA_Zj02tT.webp" alt="bad.robot logo" data-astro-cid-3ef6ksr2="true" loading="lazy" decoding="async" fetchpriority="auto" width="84" height="106" class="logo-image"> <div class="logo-text-block" data-astro-cid-3ef6ksr2> <h1 class="logo-title logo-text header-logo-text" data-astro-cid-3ef6ksr2>bad.robot</h1> <h2 class="logo-subtitle logo-subtitle-text header-subtitle" data-astro-cid-3ef6ksr2>good robots do what they&#39;re told</h2> </div> </a> </div> <nav class="nav" data-astro-cid-3ef6ksr2> <a href="/blog" data-astro-cid-3ef6ksr2>Blog</a> <a href="/book" data-astro-cid-3ef6ksr2>Books</a> <a href="/video" data-astro-cid-3ef6ksr2>Videos</a> <a href="/archive" data-astro-cid-3ef6ksr2>Archive</a> </nav> </div> </header>  <main id="site-main" class="mx-auto w-full max-w-6xl px-4 pt-4">   <div class="py-12"> <article class=""> <!--{heroImage && (--> <!--  <div class="hero-image mb-8">--> <!--    <img src={heroImage} alt={title} class="w-full h-auto rounded-lg shadow-lg" />--> <!--  </div>--> <!--)}--> <div class="article-title-section mb-8"> <p class="detail-kicker">Blog</p> <h1 class="article-title-section h1">Implicit Functions in Scala</h1> <p class="article-subtitle">Master automatic type conversions and write more succinct APIs</p> <p class="article-description">Scala implicit functions convert types automatically when the compiler needs it. Learn how implicit conversion functions work and how to use them safely.</p> </div> <div class="article-meta"> <div class="article-date"> <strong>Published:</strong> <time datetime="2015-07-14T00:00:00.000Z"> Jul 14, 2015 </time> </div>  </div> <div class="prose">  <p>In the <a href="/blog/2015-07-03-scala-implicit-parameters/">previous post</a>, we looked at implicit parameters; parameters that will be automatically passed values annotated as <code>implicit</code>. In this post, we’ll take a look at implicit functions and how they can be useful to convert things of one type to things of another.</p>
<h2 id="implicit-functions">Implicit Functions</h2>
<p>Implicit functions will be called automatically if the compiler thinks it’s a good idea to do so. What that means is that if your code doesn’t compile but would, if a call was made to an implicit function, Scala will call that function to make it compile. They’re typically used to create <em>implicit conversion functions</em>; single argument functions to automatically convert from one type to another.</p>
<p>For example, the following function allows you to convert a Scala function into a instance of the Java 8 <code>Consumer</code> <a href="/blog/2014-04-07-functional-interfaces-in-java8/">single argument method</a> but still use Scala’s concise syntax.</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="scala"><code><span class="line"><span style="color:#F97583">implicit</span><span style="color:#F97583"> def</span><span style="color:#B392F0"> toConsumer</span><span style="color:#E1E4E8">[</span><span style="color:#B392F0">A</span><span style="color:#E1E4E8">](</span><span style="color:#FFAB70">function</span><span style="color:#E1E4E8">: </span><span style="color:#B392F0">A</span><span style="color:#F97583"> =></span><span style="color:#B392F0"> Unit</span><span style="color:#E1E4E8">)</span><span style="color:#F97583">:</span><span style="color:#B392F0"> Consumer</span><span style="color:#E1E4E8">[</span><span style="color:#B392F0">A</span><span style="color:#E1E4E8">] </span><span style="color:#F97583">=</span><span style="color:#F97583"> new</span><span style="color:#B392F0"> Consumer</span><span style="color:#E1E4E8">[</span><span style="color:#B392F0">A</span><span style="color:#E1E4E8">]() {</span></span>
<span class="line"><span style="color:#F97583">  override</span><span style="color:#F97583"> def</span><span style="color:#B392F0"> accept</span><span style="color:#E1E4E8">(</span><span style="color:#FFAB70">arg</span><span style="color:#E1E4E8">: </span><span style="color:#B392F0">A</span><span style="color:#E1E4E8">)</span><span style="color:#F97583">:</span><span style="color:#B392F0"> Unit</span><span style="color:#F97583"> =</span><span style="color:#E1E4E8"> function.apply(arg)</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span></code></pre>
<p>You can avoid having to write clunky anonymous class instantiation when interfacing with Java and so mimic Java’s lambda syntax. So rather than having to use the longhand version like this.</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="scala"><code><span class="line"><span style="color:#F97583">def</span><span style="color:#B392F0"> exampleUsingJavaForEach</span><span style="color:#E1E4E8">() {</span></span>
<span class="line"><span style="color:#E1E4E8">  javaCollection.forEach(</span><span style="color:#F97583">new</span><span style="color:#B392F0"> Consumer</span><span style="color:#E1E4E8">[</span><span style="color:#B392F0">Element</span><span style="color:#E1E4E8">]() {</span></span>
<span class="line"><span style="color:#F97583">    override</span><span style="color:#F97583"> def</span><span style="color:#B392F0"> accept</span><span style="color:#E1E4E8">(</span><span style="color:#FFAB70">element</span><span style="color:#E1E4E8">: </span><span style="color:#B392F0">Element</span><span style="color:#E1E4E8">)</span><span style="color:#F97583">:</span><span style="color:#B392F0"> Unit</span><span style="color:#F97583"> =</span><span style="color:#E1E4E8"> observer.update</span></span>
<span class="line"><span style="color:#E1E4E8">  })</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span></code></pre>
<p>You can write this, where we just pass a Scala function to Java’s <code>forEach</code> method.</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="scala"><code><span class="line"><span style="color:#F97583">def</span><span style="color:#B392F0"> exampleUsingImplicitConversion</span><span style="color:#E1E4E8">() {</span></span>
<span class="line"><span style="color:#E1E4E8">  javaCollection.forEach((</span><span style="color:#FFAB70">element</span><span style="color:#E1E4E8">: </span><span style="color:#B392F0">Element</span><span style="color:#E1E4E8">) </span><span style="color:#F97583">=></span><span style="color:#E1E4E8"> observer.update)</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span></code></pre>
<p>The argument to <code>forEach</code> is actually a function of type <code>Element => Unit</code>. Scala recognises that the <code>toConsumer</code> method could convert this into a <code>Consumer[Element]</code> and does so implicitly.</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="scala"><code><span class="line"><span style="color:#F97583">def</span><span style="color:#B392F0"> exampleUsingImplicitConversion</span><span style="color:#E1E4E8">() {</span></span>
<span class="line"><span style="color:#F97583">  val</span><span style="color:#FFAB70"> function</span><span style="color:#F97583">:</span><span style="color:#B392F0"> ObserverS</span><span style="color:#F97583"> =></span><span style="color:#B392F0"> Unit</span><span style="color:#F97583"> =</span><span style="color:#E1E4E8"> (observer) </span><span style="color:#F97583">=></span><span style="color:#E1E4E8"> observer.update</span></span>
<span class="line"><span style="color:#E1E4E8">  javaCollection.forEach(function)</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span></code></pre>
<p>Which is basically shorthand for this.</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="scala"><code><span class="line"><span style="color:#F97583">def</span><span style="color:#B392F0"> exampleUsingImplicitConversion</span><span style="color:#E1E4E8">() {</span></span>
<span class="line"><span style="color:#F97583">  val</span><span style="color:#FFAB70"> function</span><span style="color:#F97583">:</span><span style="color:#B392F0"> ObserverS</span><span style="color:#F97583"> =></span><span style="color:#B392F0"> Unit</span><span style="color:#F97583"> =</span><span style="color:#E1E4E8"> (observer) </span><span style="color:#F97583">=></span><span style="color:#E1E4E8"> observer.update(</span><span style="color:#79B8FF">this</span><span style="color:#E1E4E8">, status)</span></span>
<span class="line"><span style="color:#E1E4E8">  javaCollection.forEach(toConsumer(function))</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span></code></pre>
<h2 id="another-example">Another Example</h2>
<p>If we have a button on we web page that we’d like to find using <a href="http://www.seleniumhq.org/projects/webdriver/">Web Driver</a>, we’d normally write something like the following, using a “locator” to locate it by <code>id</code> attribute.</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="scala"><code><span class="line"><span style="color:#F97583">  val</span><span style="color:#FFAB70"> button</span><span style="color:#F97583">:</span><span style="color:#B392F0"> WebElement</span><span style="color:#F97583"> =</span><span style="color:#E1E4E8"> driver.findElement(</span><span style="color:#B392F0">By</span><span style="color:#E1E4E8">.id(</span><span style="color:#9ECBFF">"save-button"</span><span style="color:#E1E4E8">)</span></span>
<span class="line"><span style="color:#E1E4E8">  button.click()</span></span></code></pre>
<p>It doesn’t take into account that the element might not be there when we call it (for example, when our UI uses ajax and adds the button asynchronously) and it’s also a bit verbose. We can use an implicit function to address both of these issues.</p>
<p>The fragment below uses the <a href="https://selenium.googlecode.com/git/docs/api/java/index.html?org/openqa/selenium/support/ui/WebDriverWait.html"><code>WebDriverWait</code></a> class to wait for a UI element to appear on the screen (using <code>findElement</code> to check and retrying if necessary) and so smooths out the asynchronous issues.</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="scala"><code><span class="line"><span style="color:#F97583">implicit</span><span style="color:#F97583"> def</span><span style="color:#B392F0"> waitForElement</span><span style="color:#E1E4E8">(</span><span style="color:#FFAB70">locator</span><span style="color:#E1E4E8">: </span><span style="color:#B392F0">By</span><span style="color:#E1E4E8">)</span><span style="color:#F97583">:</span><span style="color:#B392F0"> WebElement</span><span style="color:#F97583"> =</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#F97583">  val</span><span style="color:#FFAB70"> predicate</span><span style="color:#F97583">:</span><span style="color:#B392F0"> WebDriver</span><span style="color:#F97583"> =></span><span style="color:#B392F0"> WebElement</span><span style="color:#F97583"> =</span><span style="color:#E1E4E8"> _.findElement(locator)</span></span>
<span class="line"><span style="color:#F97583">  new</span><span style="color:#B392F0"> WebDriverWait</span><span style="color:#E1E4E8">(driver, </span><span style="color:#79B8FF">30</span><span style="color:#E1E4E8">).withMessage(</span><span style="color:#F97583">s</span><span style="color:#9ECBFF">"waiting for element '</span><span style="color:#E1E4E8">$locator</span><span style="color:#9ECBFF">' on page '</span><span style="color:#E1E4E8">${driver.getCurrentUrl}</span><span style="color:#9ECBFF">"</span><span style="color:#E1E4E8">).until(predicate)</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span></code></pre>
<p>It’s also an implicit function designed to convert a <code>By</code> locator into a <code>WebElement</code>. It means we can write something like the following where <code>button</code> is no longer a <code>WebElement</code>, but a <code>By</code>.</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="scala"><code><span class="line"><span style="color:#F97583">  val</span><span style="color:#FFAB70"> button</span><span style="color:#F97583"> =</span><span style="color:#B392F0"> By</span><span style="color:#E1E4E8">.id(</span><span style="color:#9ECBFF">"save-button"</span><span style="color:#E1E4E8">)</span></span>
<span class="line"><span style="color:#E1E4E8">  button.click()</span></span></code></pre>
<p>Without the implicit <code>waitForElement</code> function, the code wouldn’t compile; <code>By</code> doesn’t have a <code>click</code> method on it. With the implicit function in scope however, the compiler works out that calling it (and passing in <code>create</code> as the argument), would return something that <em>does</em> have the <code>click</code> method and would compile.</p>
<h2 id="single-arguments-only-please">Single Arguments Only Please</h2>
<p>Now there’s one little bit I’ve brushed over here; namely how the <code>WebDriver</code> <code>driver</code> instance is made available. The example above assumes it’s available but it’d be nicer to pass it into the function along with <code>locator</code>. However, there’s a restriction of passing only a single argument into an implicit function. The answer is to use a second argument (using Scala’s built in <a href="/blog/2013-07-21-curried-functions/">currying support</a>). By combining implicit parameters the we saw in the <a href="/blog/2015-07-03-scala-implicit-parameters/">previous post</a>, we can maintain the elegant API.</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="scala"><code><span class="line"><span style="color:#F97583">implicit</span><span style="color:#F97583"> def</span><span style="color:#B392F0"> waitForElement</span><span style="color:#E1E4E8">(</span><span style="color:#FFAB70">locator</span><span style="color:#E1E4E8">: </span><span style="color:#B392F0">By</span><span style="color:#E1E4E8">)(</span><span style="color:#F97583">implicit</span><span style="color:#FFAB70"> driver</span><span style="color:#E1E4E8">: </span><span style="color:#B392F0">WebDriver</span><span style="color:#F97583">:</span><span style="color:#B392F0"> WebElement</span><span style="color:#F97583"> =</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#F97583">  val</span><span style="color:#FFAB70"> predicate</span><span style="color:#F97583">:</span><span style="color:#B392F0"> WebDriver</span><span style="color:#F97583"> =></span><span style="color:#B392F0"> WebElement</span><span style="color:#F97583"> =</span><span style="color:#E1E4E8"> _.findElement(locator)</span></span>
<span class="line"><span style="color:#F97583">  new</span><span style="color:#B392F0"> WebDriverWait</span><span style="color:#E1E4E8">(driver, </span><span style="color:#79B8FF">30</span><span style="color:#E1E4E8">).withMessage(</span><span style="color:#F97583">s</span><span style="color:#9ECBFF">"waiting for element '</span><span style="color:#E1E4E8">$locator</span><span style="color:#9ECBFF">' on page '</span><span style="color:#E1E4E8">${driver.getCurrentUrl}</span><span style="color:#9ECBFF">"</span><span style="color:#E1E4E8">).until(predicate)</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span></code></pre>
<p>So the full example would look like this; making <code>driver</code> an implicit <code>val</code> means we can avoid a call to <code>button.click()(driver)</code>.</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="scala"><code><span class="line"><span style="color:#F97583">class</span><span style="color:#B392F0"> ExampleWebDriverTest</span><span style="color:#F97583"> extends</span><span style="color:#E1E4E8"> mutable.</span><span style="color:#B392F0">Specification</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">  implicit</span><span style="color:#F97583"> val</span><span style="color:#FFAB70"> driver</span><span style="color:#F97583">:</span><span style="color:#B392F0"> WebDriver</span><span style="color:#F97583"> =</span><span style="color:#B392F0"> Browser</span><span style="color:#E1E4E8">.create.driver</span></span>
<span class="line"></span>
<span class="line"><span style="color:#9ECBFF">  "The 'save' button writes to the database"</span><span style="color:#F97583"> >></span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#F97583">    val</span><span style="color:#FFAB70"> button</span><span style="color:#F97583"> =</span><span style="color:#B392F0"> By</span><span style="color:#E1E4E8">.id(</span><span style="color:#9ECBFF">"save"</span><span style="color:#E1E4E8">)</span></span>
<span class="line"><span style="color:#E1E4E8">    </span></span>
<span class="line"><span style="color:#6A737D">    // scala calls the implicit def to convert the button into a WebElement</span></span>
<span class="line"><span style="color:#E1E4E8">    button.click()        </span></span>
<span class="line"><span style="color:#6A737D">    // ...</span></span>
<span class="line"><span style="color:#E1E4E8">  }</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span></code></pre>
<h2 id="roundup">Roundup</h2>
<p>You can see from the examples above that implicit functions (and often combining them with implicit values) can make for succinct and more readable APIs. Next we’ll look at implicit classes.</p>
<p>If you’re interested in more Java bridge implicits like <code>toConsumer</code>, check out this <a href="https://gist.github.com/tobyweston/0fbb8eb114db48596e6b">gist</a>.</p>  </div> </article> </div>  </main> <footer class="py-8 border-t border-gray-200 mt-12"> <div class="container mx-auto px-4 text-center"> <p class="text-xs text-gray-600">&copy; 2008-2026 Toby Weston. All rights reserved. (see some old <a class="text-gray-600 hover:text-sky-600" href="/code/">code</a>)</p> </div> </footer> </body></html>
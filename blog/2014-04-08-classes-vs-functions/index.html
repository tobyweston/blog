<!DOCTYPE html><html lang="en"> <head><!-- Global Metadata --><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1"><link rel="icon" type="image/x-icon" href="/favicon.ico"><meta name="generator" content="Astro v5.17.3"><meta name="robots" content="index, follow, max-image-preview:large, max-snippet:-1, max-video-preview:-1"><!-- Canonical URL --><link rel="canonical" href="https://baddotrobot.com/blog/2014-04-08-classes-vs-functions/"><!-- RSS Feed --><link rel="alternate" type="application/rss+xml" title="bad.robot" href="/rss.xml"><!-- Primary Meta Tags --><title>Classes vs. Functions</title><meta name="title" content="Classes vs. Functions"><meta name="description" content="Java 8 lambdas are not just syntactic sugar over anonymous classes. Explores the underlying bytecode differences and why lambdas and anonymous classes behave differently."><meta name="keywords" content="Java 8, lambda, anonymous class, invokedynamic, class vs function, LambdaMetafactory, bytecode"><!-- Open Graph / Facebook --><meta property="og:type" content="website"><meta property="og:url" content="https://baddotrobot.com/blog/2014-04-08-classes-vs-functions/"><meta property="og:title" content="Classes vs. Functions"><meta property="og:description" content="Java 8 lambdas are not just syntactic sugar over anonymous classes. Explores the underlying bytecode differences and why lambdas and anonymous classes behave differently."><meta property="og:image" content="https://baddotrobot.com/images/heroes/java-code.jpg"><meta property="og:site_name" content="bad.robot"><!-- Twitter --><meta property="twitter:card" content="summary_large_image"><meta property="twitter:url" content="https://baddotrobot.com/blog/2014-04-08-classes-vs-functions/"><meta property="twitter:title" content="Classes vs. Functions"><meta property="twitter:description" content="Java 8 lambdas are not just syntactic sugar over anonymous classes. Explores the underlying bytecode differences and why lambdas and anonymous classes behave differently."><meta property="twitter:image" content="https://baddotrobot.com/images/heroes/java-code.jpg"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","headline":"Classes vs. Functions","description":"Java 8 lambdas are not just syntactic sugar over anonymous classes. Explores the underlying bytecode differences and why lambdas and anonymous classes behave differently.","datePublished":"2014-04-08T00:00:00.000Z","dateModified":"2014-11-25T00:00:00.000Z","image":"https://baddotrobot.com/images/heroes/java-code.jpg","url":"https://baddotrobot.com/blog/2014-04-08-classes-vs-functions/","author":{"@type":"Person","name":"Toby Weston","url":"https://baddotrobot.com"},"publisher":{"@type":"Person","name":"bad.robot"}}</script><link rel="stylesheet" href="/_astro/index.CzF6U4o9.css">
<link rel="stylesheet" href="/_astro/_slug_.DbZHOt6G.css"></head> <body class="bg-white text-gray-900"> <header class="header" data-astro-cid-3ef6ksr2> <div class="header-container" data-astro-cid-3ef6ksr2> <div class="logo-section" data-astro-cid-3ef6ksr2> <a href="/" class="logo-link" data-astro-cid-3ef6ksr2> <img src="/_astro/robot-logo_105x132.N1ZQY9mA_Zj02tT.webp" alt="bad.robot logo" data-astro-cid-3ef6ksr2="true" loading="lazy" decoding="async" fetchpriority="auto" width="84" height="106" class="logo-image"> <div class="logo-text-block" data-astro-cid-3ef6ksr2> <h1 class="logo-title logo-text header-logo-text" data-astro-cid-3ef6ksr2>bad.robot</h1> <h2 class="logo-subtitle logo-subtitle-text header-subtitle" data-astro-cid-3ef6ksr2>good robots do what they&#39;re told</h2> </div> </a> </div> <nav class="nav" data-astro-cid-3ef6ksr2> <a href="/blog" data-astro-cid-3ef6ksr2>Blog</a> <a href="/book" data-astro-cid-3ef6ksr2>Books</a> <a href="/video" data-astro-cid-3ef6ksr2>Videos</a> <a href="/archive" data-astro-cid-3ef6ksr2>Archive</a> </nav> </div> </header>  <main id="site-main" class="mx-auto w-full max-w-6xl px-4 pt-4">   <div class="py-12"> <article class=""> <!--{heroImage && (--> <!--  <div class="hero-image mb-8">--> <!--    <img src={heroImage} alt={title} class="w-full h-auto rounded-lg shadow-lg" />--> <!--  </div>--> <!--)}--> <div class="article-title-section mb-8"> <p class="detail-kicker">Blog</p> <h1 class="article-title-section h1">Classes vs. Functions</h1>  <p class="article-description">Java 8 lambdas are not just syntactic sugar over anonymous classes. Explores the underlying bytecode differences and why lambdas and anonymous classes behave differently.</p> </div> <div class="article-meta"> <div class="article-date"> <strong>Published:</strong> <time datetime="2014-04-08T00:00:00.000Z"> Apr 8, 2014 </time> </div> <div class="article-date"> <strong>Updated:</strong> <time datetime="2014-11-25T00:00:00.000Z"> Nov 25, 2014 </time> </div> </div> <div class="prose">  <p>You can use lambdas in Java 8 anywhere you would have previously used a <a href="/blog/2014-04-07-functional-interfaces-in-java8">single method interface</a> so it may just look like syntactic sugar, but it’s not. Let’s have a look at how they differ; it’s anonymous classes vs. lambdas or simply put, classes vs. functions.</p>
<p>So, a typical implementation of an anonymous class (a single method interface) in Java pre-8, might look something like this. The <code>anonymousClass</code> method is calling the <code>waitFor</code> method passing in some implementation of <code>Condition</code>, in this case it’s saying wait for some server to have shutdown.</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="java"><code><span class="line"><span style="color:#F97583">void</span><span style="color:#B392F0"> anonymousClass</span><span style="color:#E1E4E8">() {</span></span>
<span class="line"><span style="color:#F97583">    final</span><span style="color:#E1E4E8"> Server server </span><span style="color:#F97583">=</span><span style="color:#F97583"> new</span><span style="color:#B392F0"> HttpServer</span><span style="color:#E1E4E8">();</span></span>
<span class="line"><span style="color:#B392F0">    waitFor</span><span style="color:#E1E4E8">(</span><span style="color:#F97583">new</span><span style="color:#B392F0"> Condition</span><span style="color:#E1E4E8">() {</span></span>
<span class="line"><span style="color:#E1E4E8">        @</span><span style="color:#F97583">Override</span></span>
<span class="line"><span style="color:#F97583">        public</span><span style="color:#E1E4E8"> Boolean </span><span style="color:#B392F0">isSatisfied</span><span style="color:#E1E4E8">() {</span></span>
<span class="line"><span style="color:#F97583">            return</span><span style="color:#F97583"> !</span><span style="color:#E1E4E8">server.</span><span style="color:#B392F0">isRunning</span><span style="color:#E1E4E8">();</span></span>
<span class="line"><span style="color:#E1E4E8">        }</span></span>
<span class="line"><span style="color:#E1E4E8">    });</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span></code></pre>
<p>The functionally equivalent lambda would look like this.</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="java"><code><span class="line"><span style="color:#F97583">void</span><span style="color:#B392F0"> closure</span><span style="color:#E1E4E8">() {</span></span>
<span class="line"><span style="color:#E1E4E8">    Server server </span><span style="color:#F97583">=</span><span style="color:#F97583"> new</span><span style="color:#B392F0"> HttpServer</span><span style="color:#E1E4E8">();</span></span>
<span class="line"><span style="color:#B392F0">    waitFor</span><span style="color:#E1E4E8">(() </span><span style="color:#F97583">-></span><span style="color:#F97583"> !</span><span style="color:#E1E4E8">server.</span><span style="color:#B392F0">isRunning</span><span style="color:#E1E4E8">());</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span></code></pre>
<p>Where in the interest of completeness, a naive polling <code>waitFor</code> method might look like this.</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="java"><code><span class="line"><span style="color:#F97583">class</span><span style="color:#B392F0"> WaitFor</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#F97583">	static</span><span style="color:#F97583"> void</span><span style="color:#B392F0"> waitFor</span><span style="color:#E1E4E8">(Condition </span><span style="color:#FFAB70">condition</span><span style="color:#E1E4E8">) </span><span style="color:#F97583">throws</span><span style="color:#E1E4E8"> InterruptedException {</span></span>
<span class="line"><span style="color:#F97583">		while</span><span style="color:#E1E4E8"> (</span><span style="color:#F97583">!</span><span style="color:#E1E4E8">condition.</span><span style="color:#B392F0">isSatisfied</span><span style="color:#E1E4E8">())</span></span>
<span class="line"><span style="color:#E1E4E8">			Thread.</span><span style="color:#B392F0">sleep</span><span style="color:#E1E4E8">(</span><span style="color:#79B8FF">250</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#E1E4E8">	}</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span></code></pre>
<h2 id="some-theoretical-differences">Some Theoretical Differences</h2>
<p>Firstly, both implementations are in-fact closures, the latter is also a lambda. Confused, see <a href="/blog/2010-07-13-lambdas-vs-closures">my distinction between lambdas and closures</a>. This means that both have to capture their “environment” at runtime. In Java pre-8, this means copying the things the closure needs into an instance of a class (an anonymous instances of <code>Condition</code>). In our example, the <code>server</code> variable.</p>
<p>As it’s a copy, it has to be declared final to ensure that it can not be changed between when it’s captured and when it’s used. These two points in time could be very different given that closures are often used to defer execution until some later point (see <a href="http://en.wikipedia.org/wiki/Lazy_evaluation">lazy evaluation</a> for example). Java 8 uses a neat trick whereby if it can reason that a variable is never updated, it might as well be final so it treats it as “effectively final” and you don’t need to declare it as <code>final</code> explicitly.</p>
<p>A lambda on the other hand, doesn’t need to copy its environment or <em>capture any terms</em>. This means it can be treated as a genuine function and not an instance of a class. What’s the difference? Plenty.</p>
<h3 id="functions-vs-classes">Functions vs. Classes</h3>
<p>For a start, functions; <a href="http://en.wikipedia.org/wiki/Pure_function">genuine functions</a>, don’t need to be instantiated many times. I’m not sure if instantiation is even the right word to use when talking about allocating memory and loading a chunk of machine code as a function. The point is, once it’s available, it can be re-used, it’s idempotent in nature as it retains no state. Static class methods are the closest thing Java has to functions.</p>
<p>For Java, this means that a lambda need not be instantiated every time it’s evaluated which is a big deal. Unlike instantiating an anonymous class, the memory impact should be minimal.</p>
<p>In terms of some conceptual differences then;</p>
<ul>
<li>Classes must be instantiated, whereas functions are not.</li>
<li>When classes are newed up, memory is allocated for the object.</li>
<li>Memory need only be allocated once for functions. They are stored in the “permanent” area of the heap.</li>
<li>Objects act on their own data, functions act on unrelated data.</li>
<li>Static class methods in Java are roughly equivalent to functions.</li>
</ul>
<h2 id="some-concrete-differences">Some Concrete Differences</h2>
<h3 id="capture-semantics">Capture Semantics</h3>
<p>Another difference is around capture semantics for <code>this</code>. In an anonymous class, <code>this</code> refers to the instance of the anonymous class. For example, <code>Foo$InnerClass</code> and not <code>Foo</code>. That’s why you have whacky syntax like <code>Foo.this.x</code> when you refer to the enclosing scope from the anonymous class.</p>
<p>In lambdas on the other hand, <code>this</code> refers to the enclosing scope (<code>Foo</code> directly in our example). In fact, lambdas are <strong>entirely lexically scoped</strong>, meaning they don’t inherit any names from a super type or introduce a new level of scoping at all; you can directly access fields, methods and local variables from the enclosing scope.</p>
<p>For example, this class shows that the lambda can reference the <code>firstName</code> variable directly.</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="java"><code><span class="line"><span style="color:#F97583">public</span><span style="color:#F97583"> class</span><span style="color:#B392F0"> Example</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">	private</span><span style="color:#E1E4E8"> String firstName </span><span style="color:#F97583">=</span><span style="color:#9ECBFF"> "Jack"</span><span style="color:#E1E4E8">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">	public</span><span style="color:#F97583"> void</span><span style="color:#B392F0"> example</span><span style="color:#E1E4E8">() {</span></span>
<span class="line"><span style="color:#E1E4E8">		Function&#x3C;</span><span style="color:#F97583">String</span><span style="color:#E1E4E8">, </span><span style="color:#F97583">String</span><span style="color:#E1E4E8">> addSurname </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> surname </span><span style="color:#F97583">-></span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#F97583">			return</span><span style="color:#E1E4E8"> firstName </span><span style="color:#F97583">+</span><span style="color:#9ECBFF"> " "</span><span style="color:#F97583"> +</span><span style="color:#E1E4E8"> surname;       </span><span style="color:#6A737D">// equivalent to this.firstName</span></span>
<span class="line"><span style="color:#E1E4E8">		};</span></span>
<span class="line"><span style="color:#E1E4E8">	}</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span></code></pre>
<p>The anonymous class equivalent would need to explicitly refer to <code>firstName</code> from the enclosing scope.</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="java"><code><span class="line"><span style="color:#F97583">public</span><span style="color:#F97583"> class</span><span style="color:#B392F0"> Example</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">	private</span><span style="color:#E1E4E8"> String firstName </span><span style="color:#F97583">=</span><span style="color:#9ECBFF"> "Charlie"</span><span style="color:#E1E4E8">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">    public</span><span style="color:#F97583"> void</span><span style="color:#B392F0"> anotherExample</span><span style="color:#E1E4E8">() {</span></span>
<span class="line"><span style="color:#E1E4E8">        Function&#x3C;</span><span style="color:#F97583">String</span><span style="color:#E1E4E8">, </span><span style="color:#F97583">String</span><span style="color:#E1E4E8">> addSurname </span><span style="color:#F97583">=</span><span style="color:#F97583"> new</span><span style="color:#E1E4E8"> Function&#x3C;</span><span style="color:#F97583">String</span><span style="color:#E1E4E8">, </span><span style="color:#F97583">String</span><span style="color:#E1E4E8">>() {</span></span>
<span class="line"><span style="color:#E1E4E8">            @</span><span style="color:#F97583">Override</span></span>
<span class="line"><span style="color:#F97583">            public</span><span style="color:#E1E4E8"> String </span><span style="color:#B392F0">apply</span><span style="color:#E1E4E8">(String </span><span style="color:#FFAB70">surname</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#F97583">                return</span><span style="color:#E1E4E8"> Example.this.firstName </span><span style="color:#F97583">+</span><span style="color:#9ECBFF"> " "</span><span style="color:#F97583"> +</span><span style="color:#E1E4E8"> surname;</span></span>
<span class="line"><span style="color:#E1E4E8">            }</span></span>
<span class="line"><span style="color:#E1E4E8">        };</span></span>
<span class="line"><span style="color:#E1E4E8">    }</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span></code></pre>
<p>Shadowing also becomes much more straight forward to reason about (when referencing shadowed variables).</p>
<h3 id="byte-code-differences">Byte Code Differences</h3>
<p>The other thing to note is the byte code an anonymous class implementation produces compared to the lambda byte-code. The former will use the <code>invokespecial</code> whereas a lambda uses <code>invokedynamic</code>. The difference is about when the caller is linked to a destination; lambdas are matched at <em>runtime</em> (<code>invokedynamic</code>) rather than compile time (<code>invokespecial</code> and <code>invokevirtual</code>).</p>
<p>This may not seem like a big deal but the main take-away is that these instructions can be optimised by the JVM. We can expect dynamic invocations (and so lambdas) to out-perform their more traditional counterparts.</p>
<p>The <code>invokedynamic</code> instruction was originally motivated by supporting more dynamic languages on the JVM. With it, you don’t need to know the types ahead of time (statically typed) and you can relax these constraints and support dynamically typed languages (like JavaScript). However, it can be used to do so much more.</p>
<p>It links into type inference and target typing with Java 8, supporting method references (method handles), default methods, removing the need to create intermediary anonymous instances, avoid bridge methods as well as optimisation opportunities. It’s introduction in Java 7 was under the radar for the mainstream but it’s probably the biggest proponent to supporting Java 8 features like lambdas. It’s the mechanism by which Java achieves no additional class loading when using lambdas.</p>
<h2 id="summary">Summary</h2>
<p>So there we have it. Functions in the academic sense are very different things from anonymous classes (which we often treat like functions in Java pre-8). I find it useful to keep the distinctions in my head as I feel that I need to be able to justify the use of Java 8 lambdas in my code with more than just arguing for their concise syntax. Of course, there’s lots of additional advantages in using lambdas (not least the retrofit of the JDK to heavily use them), but I want to be able to respond when people say “isn’t that just syntactic sugar over anonymous classes?”.</p>  </div> </article> </div>  </main> <footer class="py-8 border-t border-gray-200 mt-12"> <div class="container mx-auto px-4 text-center"> <p class="text-xs text-gray-600">&copy; 2008-2026 Toby Weston. All rights reserved. (see some old <a class="text-gray-600 hover:text-sky-600" href="/code/">code</a>)</p> </div> </footer> </body></html>
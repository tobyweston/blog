<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: java, | bad.robot]]></title>
  <link href="http://baddotrobot.com/blog/categories/java-/atom.xml" rel="self"/>
  <link href="http://baddotrobot.com/"/>
  <updated>2014-03-19T21:18:10+00:00</updated>
  <id>http://baddotrobot.com/</id>
  <author>
    <name><![CDATA[Toby Weston]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Method References in Java 8]]></title>
    <link href="http://baddotrobot.com/blog/2014/02/18/method-references-in-java8/"/>
    <updated>2014-02-18T21:33:00+00:00</updated>
    <id>http://baddotrobot.com/blog/2014/02/18/method-references-in-java8</id>
    <content type="html"><![CDATA[<p>Java 8 brings with it method references; shortcuts that you can use anywhere you would use a lambda. The <a href="http://docs.oracle.com/javase/tutorial/java/javaOO/methodreferences.html">Oracle docs</a> describe four types of method reference but do such a poor job of describing them that I felt compelled to describe them myself.</p>

<!-- more -->


<p><a href="http://docs.oracle.com/javase/tutorial/java/javaOO/methodreferences.html">Oracle describe the four kinds of method reference</a> as follows.</p>

<table>
<thead>
<tr>
<th></th>
<th> Kind                                                                           </th>
<th> Example                                </th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td> Reference to a static method                                                   </td>
<td> <code>ContainingClass::staticMethodName</code></td>
</tr>
<tr>
<td></td>
<td> Reference to an instance method of a particular object                         </td>
<td> <code>ContainingObject::instanceMethodName</code></td>
</tr>
<tr>
<td></td>
<td> Reference to an instance method of an arbitrary object of a particular type    </td>
<td> <code>ContainingType::methodName</code></td>
</tr>
<tr>
<td></td>
<td> Reference to a constructor                                                     </td>
<td> <code>ClassName::new</code></td>
</tr>
</tbody>
</table>


<p>Static and constructor references are straight forward but it's their description of instance method references that muddies the waters. What on earth is an instance method of an arbitrary object of a particular type? Aren't all objects <em>of a</em> particular type?  Why is it important that the object is <em>arbitrary</em>?</p>

<h2>What they should have written</h2>

<p>It's talking about four types of method reference; constructor references, static method references, instance method references and what it calls instance method references of a particular type. The last one is really just another kind of instance method reference.</p>

<p>What they should have written is this.</p>

<table>
<thead>
<tr>
<th></th>
<th> Kind                                                                 </th>
<th> Syntax                           </th>
<th> Example                  </th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td> Reference to a static method                                         </td>
<td> <code>Class::staticMethodName</code>        </td>
<td> <code>String::valueOf</code></td>
</tr>
<tr>
<td></td>
<td> Reference to an instance method of a specific object                 </td>
<td> <code>object::instanceMethodName</code>     </td>
<td> <code>x::toString</code></td>
</tr>
<tr>
<td></td>
<td> Reference to an instance method of a arbitrary object supplied later </td>
<td> <code>Class::instanceMethodName</code>      </td>
<td> <code>String::toString</code></td>
</tr>
<tr>
<td></td>
<td> Reference to a constructor                                           </td>
<td> <code>ClassName::new</code>                 </td>
<td> <code>String::new</code></td>
</tr>
</tbody>
</table>


<p>or as lambdas</p>

<table>
<thead>
<tr>
<th></th>
<th> Kind                                                                 </th>
<th> Syntax                           </th>
<th> As Lambda                  </th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td> Reference to a static method                                         </td>
<td> <code>Class::staticMethodName</code>        </td>
<td> <code>(s) -&gt; String.valueOf(s)</code></td>
</tr>
<tr>
<td></td>
<td> Reference to an instance method of a specific object                 </td>
<td> <code>object::instanceMethodName</code>     </td>
<td> <code>() -&gt; "hello".toString()</code> <strong>†</strong></td>
</tr>
<tr>
<td></td>
<td> Reference to an instance method of a arbitrary object supplied later </td>
<td> <code>Class::instanceMethodName</code>      </td>
<td> <code>(s) -&gt; s.toString()</code></td>
</tr>
<tr>
<td></td>
<td> Reference to a constructor                                           </td>
<td> <code>ClassName::new</code>                 </td>
<td> <code>() -&gt; new String()</code></td>
</tr>
</tbody>
</table>


<p>I found their description of the two confusing. I prefer to think of the first as an instance method of a <em>specific</em> object known ahead of time and the second as an instance method of an arbitrary object that will be <em>supplied</em> later. Interestingly, this means the first is a <em>closure</em> and the second is a <em>lambda</em>. One is <em>bound</em> and the other <em>unbound</em>.</p>

<p>The distinction between a method reference that closes over something (a closure) and one that doesn't (a lambda) may be a bit academic but at least it's a more formal definition than Oracle's unhelpful description. If you're interested in the difference between a closure and a lambda, check out my <a href="/blog/2010/07/13/lambdas-vs-closures">previous article</a>.</p>

<h2>The "closure" method reference</h2>

<p>The example above (<code>x::toString</code>) is an instance method reference using a closure. It creates a lambda that will call the <code>toString</code> method on the instance <code>x</code>.</p>

<p>``` java
public void example() {</p>

<pre><code>String x = "hello";
function(x::toString);
</code></pre>

<p>}
```</p>

<p>where the signature of <code>function</code> looks like this</p>

<p>``` java
public static String function(Supplier<String> supplier) {</p>

<pre><code>return supplier.get();
</code></pre>

<p>}
```</p>

<p>The <code>Supplier</code> interface must provide a string value (the <code>get</code> call) and the only way it can do that is if it's been supplied to it on construction. It's equivalent to</p>

<p>``` java
public void example() {</p>

<pre><code>String x = "hello";
function(() -&gt; x.toString());
</code></pre>

<p>}
```</p>

<p>Notice here that the lambda has no arguments (it uses the 'hamburger' symbol). This shows that the value of <code>x</code> isn't available in the lambda's local scope and so can only be available from outside it's scope. It's a closure because must close over <code>x</code>.</p>

<p>The anonymous class equivalent really makes this obvious, it looks like this.</p>

<p>``` java
public void example() {</p>

<pre><code>String x = "";
function(new Supplier&lt;String&gt;() {
    @Override
    public String get() {
        return x.toString(); // &lt;- closes over 'x'
    }
});
</code></pre>

<p>}
```</p>

<p>All three of these are equivalent. Compare this to the lambda variation of an instance method reference where it doesn't have it's argument explicitly passed in from an outside scope.</p>

<h2>The "lambda" method reference</h2>

<p>The other example (<code>String::toString</code>) is similar to the previous one, it calls the <code>toString</code> method of a string only this time, the string is supplied to the function that's making use of the lambda and not passed in from an outside scope.</p>

<p>``` java
public void lambdaExample() {</p>

<pre><code>function("value", String::toString);
</code></pre>

<p>}
```</p>

<p>The <code>String</code> part looks like it's referring to a class but it's actually referencing an instance. It's confusing, I know but to see things more clearly, we need to see the function that's making use of the lambda. It looks like this.</p>

<p>``` java
public static String function(String value, Function&lt;String, String> function) {</p>

<pre><code>return function.apply(value);
</code></pre>

<p>}
```</p>

<p>So, the string value is passed directly to the function, it would look like this as a fully qualified lambda.</p>

<p>``` java
public void lambdaExample() {</p>

<pre><code>function("value", x -&gt; x.toString());
</code></pre>

<p>}
```</p>

<p>If you expand it fully to an anonymous interface, it looks like this. The <code>x</code> parameter is made available and not closed over. It's a lambda rather than a closure.</p>

<p>``` java
public void lambdaExample() {</p>

<pre><code>function("value", new Function&lt;String, String&gt;() {
  @Override
  public String apply(String x) {   // &lt;- takes the argument as a parameter, doesn't need to close over it
    return x.toString();
  }
});
</code></pre>

<p>}
```</p>

<h2>Summary</h2>

<p>The difference between the two types of instance method reference is interesting but basically academic. Sometimes, you'll need to pass something in, other times, the usage of the lambda will supply it for you. My gripe is with Oracle's documentation. They make a big deal out of the distinction but fail to describe it in an easily understandable way. It's <em>the</em> canonical reference material but is just plain confusing. It feels like interns are producing this stuff.</p>

<h2>Caveat</h2>

<p><strong>†</strong> There's a caveat here; the example isn't a closure, so my comment about that being a distinguishing feature isn't quiet true. If, as in the later examples, it closes over some <code>x</code> (as is more likely), great. If however, you use a literal value (as in my starred example), it wont close over the term <code>x</code> so it's back to being a lambda. So doesn't <em>have</em> to be a closure, it's just more than likely to be one. For example;</p>

<p>``` java This time the "reference to an instance method of a arbitrary object supplied later" is a Lambda, not a closure
public void example() {</p>

<pre><code>// String x = "hello";
function(() -&gt; "hello".toString());
</code></pre>

<p>}
```</p>
]]></content>
  </entry>
  
</feed>

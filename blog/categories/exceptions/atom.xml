<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: exceptions | bad.robot]]></title>
  <link href="http://baddotrobot.com/blog/categories/exceptions/atom.xml" rel="self"/>
  <link href="http://baddotrobot.com/"/>
  <updated>2016-03-30T18:28:43+01:00</updated>
  <id>http://baddotrobot.com/</id>
  <author>
    <name><![CDATA[Toby Weston]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Scala Exception Handling]]></title>
    <link href="http://baddotrobot.com/blog/2012/03/30/scala-exception-handling/"/>
    <updated>2012-03-30T22:47:00+01:00</updated>
    <id>http://baddotrobot.com/blog/2012/03/30/scala-exception-handling</id>
    <content type="html"><![CDATA[<p>We're very used to Java's notion of checked exceptions. If we want to force the developer to consider exceptional behaviour then we typically throw a checked exception. The problem is that despite our best intentions, we can't force the developer to actually deal with the exception sensibly. Java tries to help by forcing a compilation error onto the developer so they at least forced to choose a course of action. The trouble is though it's all too tempting to swallow exceptions or just rethrow. We tend to either bury our heads in the sand or litter our code with addition noise.</p>

<p>Scala has taken a different approach. Scala has done away with checked exceptions; all exceptions are effectively <code>RuntimeException</code>s and so its left to the developer to decide when to handle them. This obviously leads to less noise but puts more responsibility on the developer. Scala makes it easy to avoid the issue but without a clear system wide policy for exception handling, we can still get into trouble.</p>

<p>In a <a href="{{%20root_url%20}}/blog/2012/03/29/building-better-exceptions">previous post</a>, I've described a general approach to understanding <em>when</em> and <em>how</em> to deal with exceptions in Scala or Java. In this post, we'll take a quick look at Scala's syntax around exceptions and how pattern matching is employed.</p>

<!-- more -->


<h2>Exceptions</h2>

<p>Scala essentially treats all exception types as <code>RuntimeException</code>. This means it doesn't <em>force</em> you to handle exceptions. Instead, it combines <em>pattern matching</em> with a single <code>catch</code> block to handle exceptions. For example</p>

<p>{% codeblock lang:scala %}
try {
  val url = new URL("http://baddotrobot.com")
} catch {
  case e: MalformURLException => println("bad url " + e)
  case e: IOException => println("other IO problem " + e)
  case _ => println("anything else!")
} finally {
  // cleanup
}
{% endcodeblock %}</p>

<p>Any cleanup can be achieved using the <code>finally</code> block as expected. This works exactly the same way as in Java but perhaps a more idiomatic alternative is to use the <em><a href="https://wiki.scala-lang.org/display/SYGN/Loan">loan pattern</a></em>. You can see an example of the pattern in Java form in the <code>ExecuteUsingLock</code> <a href="https://github.com/tobyweston/tempus-fugit/blob/master/src/main/java/com/google/code/tempusfugit/concurrency/ExecuteUsingLock.java">class</a> in <a href="http://tempusfugitlibrary.org/">tempus-fugit</a>.</p>

<p>Throwing exceptions is done in the same way as Java, as in the example below.</p>

<p>{% codeblock lang:scala %}
def load(url: String) {
  // ...
  throw new IOException("failed to load")
}
{% endcodeblock %}</p>

<p>However, anyone calling this method won't be forced by the compiler to catch the exception. If you intend to call your Scala code from Java however, you can force checked exceptions using the <code>throws</code> annotation but this still won't affect Scala clients.</p>

<p>{% codeblock lang:scala %}
@throws(classOf[java.io.IOException])
def load(url: String) {
  // ...
}
{% endcodeblock %}</p>

<p>Interestingly, Scala treats <code>throw</code> as an expression with a return type of <code>Nothing</code>. You can use it in place of any other expression even though the result wont actually evaluate to anything.</p>

<h2>Pattern Matching</h2>

<p>Pattern matching is a bit like a switch statement but unlike Java's switch statement, pattern matching in Scala can be used to match any kind of constant as well as other things (like <em>case objects</em>). It's not restricted to just primitives and enums as with Java (although Java 1.7 brought <code>String</code> <a href="http://docs.oracle.com/javase/7/docs/technotes/guides/language/strings-switch.html">support to switch</a>).</p>

<p>Pattern matching is applied to the exception type when using <code>catch</code> above but it's also used in its vanilla form. For example, as described in <a href="http://www.artima.com/shop/programming_in_scala_2ed">Programming in Scala</a>, we can work out what to have with dinner in the example below.</p>

<p>{% codeblock lang:scala %}
def accompaniment(dinner: String) {
  dinner match {</p>

<pre><code>case "fish" =&gt; println("chips")
case "sausage" =&gt; println("mash")
case "sheep" =&gt; println("cheese")
case _ =&gt; println("beans?")
</code></pre>

<p>  }
}
{% endcodeblock %}</p>

<p>Notice that there is no need for a <code>break</code> statement and that each match expression results in a value. So we can take advantage of resulting value and rewrite the above to the following.</p>

<p>{% codeblock lang:scala %}
def anotherAccompaniment(dinner: String) {
  val accompaniment =</p>

<pre><code>dinner match {
  case "fish" =&gt; "chips"
  case "sausage" =&gt; "mash"
  case "sheep" =&gt; "cheese"
  case _ =&gt; "beans goes with anything!"
}
</code></pre>

<p>  println(accompaniment)
}
{% endcodeblock %}</p>

<h2>Conclusion</h2>

<p>The whole thing is generally neater than the Java equivalent but as I keep banging on about, we still need to carefully consider where to apply the <code>catch</code> when handling exceptions. When using Scala, it's even more important to understand where potential exceptions will bubble up and how to <a href="{{%20root_url}}/blog/2012/03/28/exception-handling-as-a-system-wide-concern">handle them as a system wide concern</a>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Building Better Exceptions]]></title>
    <link href="http://baddotrobot.com/blog/2012/03/29/building-better-exceptions/"/>
    <updated>2012-03-29T00:00:00+01:00</updated>
    <id>http://baddotrobot.com/blog/2012/03/29/building-better-exceptions</id>
    <content type="html"><![CDATA[<p>In the <a href="{{%20root_url%20}}/blog/2012/03/28/exception-handling-as-a-system-wide-concern">previous post</a>, we looked at being more explicit about a system's exception handling policies. By identifying the boundaries within your system, you isolate the points at which you handle exceptions.</p>

<p>This post takes the idea further by talking about exceptions as <em>real</em> objects and suggests only ever creating sub-classes of <code>RuntimeException</code> for your application exceptions. Once exception handling points are isolated, testing becomes more straightforward and we reduce the noise of checked exceptions. When we get it right, we should never need to assert against exception messages.</p>

<!-- more -->


<h2>Exceptions are Objects</h2>

<p>We tend to think of exceptions as beans; objects with a <code>message</code> that we get and display. It's easy to forget that exceptions are objects too. How often do you see this type of thing in the same code base.</p>

<p>{% codeblock lang:java %}
throw new BadRequestException("the field 'customer' is missing from the request");
throw new BadRequestException("'customer' is missing");
throw new BadRequestException("can not parse request" );
{% endcodeblock %}</p>

<p>It's an example of bad encapsulation in the <code>BadRequestException</code> class. It's hard to tell if the examples above should be handled the same or differently. There's certainly an inconsistency between the wording of the first two. Are they the same error? It's also not clear where the message is going to end up? A better idea would be to create sub-classes for each.</p>

<p>{% codeblock lang:java %}
public class MissingFieldException extends BadRequestException {</p>

<pre><code>public MissingFieldException(Field field) {
    super();
    this.field = field;
}
</code></pre>

<p>}
{% endcodeblock %}</p>

<p>All other constructors have been disabled so the exception can only be constructed as we intend. It can still be handled in a <code>catch</code> block built for <code>BadRequest</code> (and it's there that we would decide how to map the exception type to a presentable form). We've intentionally <em>avoided</em> something like</p>

<p>{% codeblock lang:java %}
public MissingFieldException(Field field) {</p>

<pre><code>super("the field '" + "' is missing from the request");
</code></pre>

<p>}
{% endcodeblock %}</p>

<p>because the message is completely unimportant to the exception. It's the handling that's important and it's in the catch block that we can map to a message (if appropriate). We're encapsulating the internal details. For example, at the UI, we may map the exception to a message for display but at an internal boundary, we may generate an event for support staff that maps to a different message.</p>

<p>Applying object oriented principles like encapsulation to exceptions means that they can do more than just be <em>caught</em>. As first class objects, they can carry <em>behaviour</em> and so can be tested appropriately. How many <em>unit</em> tests have you written for an <code>Exception</code> class?</p>

<h2>Tell. Don't ask</h2>

<p>We can take this further and try to apply the <a href="http://en.wikipedia.org/wiki/Law_of_Demeter">law of demeter</a> to our objects. Rather than <em>get</em> something and perform conditional logic based on it, we should be able to <em>tell</em> the object to do something. It can make decisions based on its internal, encapsulated data which means decision points are localised to appropriate places.</p>

<p>How do we apply this to exceptions? Well, now we've got nicely encapsulated data it's clear that the exception itself is responsible for <em>using</em> it. In the example above, we've encapsulated a <code>field</code> object. The implication being that the exception may want to influence something based on it. This could be the simple case where the exception can <em>present itself to some object</em>, in this example an implementation of a <code>Description</code> interface.</p>

<p>{% codeblock lang:java %}
public void applyTo(Description description) {</p>

<pre><code>description.append("the field").appendValue(field).append("is missing from the request");
</code></pre>

<p>}
{% endcodeblock %}</p>

<h2>The Impact on Testing</h2>

<p>If we handle exceptions <em>only</em> at the boundaries, we do so based on <em>type</em> in the <code>catch</code> block. Even at this point, we shouldn't ask for the internals of the exception and so we shouldn't have to <em>test against them</em>. The handler can <em>tell</em> the exception rather than <em>ask</em> and testing becomes much more straight forward.</p>

<p>{% pullquote %}
If a class throws an exception, <em>{" we should never need to test the content of the message in a unit test "}</em> for that class. It's the class that would use the message that should be tested. However, if we've done things correctly, then no behaviour should depend on the message so what can we test?
{% endpullquote %}</p>

<p>The first part is to test that the handling class responds appropriately to the exception <em>type</em> and that those exceptions are generated only at appropriate times. The second part is that if the handling class does depend on some internal details, we should encapsulate this, apply <em>tell don't ask</em> and so can write simpler tests.</p>

<p>In this way, we're just applying the <a href="{{%20root_url%20}}/blog/2012/02/13/hexagonal-acceptance-testing">ports and adaptors</a> idea to write overlapping tests which combine for coverage but are still simple on their own.</p>

<h2>Only using Runtime Exceptions</h2>

<p>If you isolate exception handling to a specific boundary, you emphasise the point at which exceptions are caught. If you're catching and dealing with exceptions in a single, well known place, why would you need to use checked exceptions?</p>

<p>Checked exceptions cause noise. That's all. Nothing else bad about them but they imply a defensive style of programming that has no place in the brave world of XP. The alternative, to throw only runtime exceptions, seems fraught with danger. What if you forget to catch it? If you've setup a exception handling as a system wide policy, you would have already established where to catch them and you'll have programmatically prevented that scenario.</p>

<p> If that's truly the case, you can create application specific exceptions that sub-class <code>RuntimeException</code> and clean up the code base considerably. However, it's a potentially bad idea to actually throw <code>RuntimeException</code> as this subverts the explicit catching strategy. I generally consider <code>RuntimeException</code> as an abstract class. It doesn't make sense on its own because it implies any <code>catch</code> clause is too generic. Instead, create an root application exception that extends <code>RuntimeException</code>.</p>

<p> {% codeblock lang:java %}
 public class BadRobotApplicationException extends RuntimeException {</p>

<pre><code>// ...
</code></pre>

<p> }
 {% endcodeblock %}</p>

<p>In the next post <a href="{{%20root_url%20}}/blog/2012/03/30/scala-exception-handling">Scala Exception Handling</a>, well take a look at how Scala embraces some of these ideas. For example, in Scala <em>all</em> exceptions are based on <code>RuntimeException</code>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Exception Handling as a System Wide Concern]]></title>
    <link href="http://baddotrobot.com/blog/2012/03/28/exception-handling-as-a-system-wide-concern/"/>
    <updated>2012-03-28T00:00:00+01:00</updated>
    <id>http://baddotrobot.com/blog/2012/03/28/exception-handling-as-a-system-wide-concern</id>
    <content type="html"><![CDATA[<p>It's not ok to handle exceptions in an ad-hoc way. Exception handling should be a <strong>system wide concern</strong>. That means catching an exception, arbitrarily logging it before rethrowing isn't a good idea. We should be carefully considering <em>when</em> and <em>how</em> to handle exceptions. With a high level strategy, things just become easier. You focus exception handling to just a few places making it easy to test and easy to apply consistently.</p>

<p>In this post, we'll take a closer look with some examples.</p>

<!-- more -->


<p>To help make the strategy explicit, it's a good general approach to deal with exceptions at the boundaries of your system. However, recognising the boundaries can be tricky. The UI is an obvious boundary. Here, the user will likely be interested that something went wrong. Architectural "layers" can be more subtle. For example, any internal API is a candidate but you have to consider them carefully. Lets take a look at a few examples, in each case we'll identify the boundary, <em>when</em> to catch exceptions and <em>how</em> to deal with them. Effectively, we'll define a system wide strategy for each of the following.</p>

<ul>
<li>Low level exceptions which propagate to the UI</li>
<li>An example of an externally facing API, in our case, a RESTful service</li>
<li>Maintaining data atomicity in the face of failures</li>
</ul>


<h2>The UI Boundary</h2>

<p>A user probably isn't interested in seeing details of the majority of your exceptions. A user should certainly not be presented with a Java stack trace when visiting a public web site.</p>

<p>Lets have a look at the example when a user's session times out. The server will generate a <code>SessionExpiredException</code> on subsequent requests but we don't want to relay this to the user.</p>

<p>For the <em>when</em>, most web UI frameworks have a convenient mechanism. In the servlet space, you can declaratively configure a page to be displayed based on an exception type.</p>

<p>{% codeblock lang:xml %}
<error-page></p>

<pre><code>&lt;exception-type&gt;bad.robot.example.SessionExpiredException&lt;/exception-type&gt;
&lt;location&gt;/login&lt;/location&gt;
</code></pre>

<p></error-page>
<error-page></p>

<pre><code>&lt;exception-type&gt;bad.robot.example.Defect&lt;/exception-type&gt;
&lt;location&gt;/internalServerError&lt;/location&gt;
</code></pre>

<p></error-page>
{% endcodeblock %}</p>

<p>For the <em>how</em>, the approach at this layer is to <em>translate</em> an underlying exception into something appropriate. This could just mean something that is more presentable to the user. In the example above, when the server is asked to work with a session that has expired, it will generate the <code>SessionExpiredException</code>. This in turn causes the <code>login</code> page to be displayed prompting the user to log back in. No stack traces appear and we allow the user to continue working.</p>

<h2>The API Boundary</h2>

<p>Lets consider a RESTful web service that allows a client to <code>GET</code> customer details via a URL. To get the most out of HTTP interoperability, the correct response to a request for unknown customer details is to return the HTTP response code <code>404</code> (Not Found). In the backend however, we throw a <code>CustomerNotFoundException</code>.</p>

<p>For the <em>when</em>, again, this layer is about <em>translation</em>. We would like to turn the <code>Exception</code> into a HTTP response code at the point at which the response is generated. We can propagate the exception up through the stack until the last possible point.</p>

<p>For <a href="http://jersey.java.net/">Jersey</a>, this means the <em>how</em> is taken care of declaratively by providing an <a href="http://jersey.java.net/nonav/documentation/latest/user-guide.html#d4e435"><code>ExceptionMapper</code></a> as below.</p>

<p>{% codeblock lang:java %}
@Provider
public class NotFoundExceptionMapper implements ExceptionMapper<NotFoundException> {</p>

<pre><code>public Response toResponse(CustomerNotFoundException notFound) {
    return Response.status(404).entity(notFound.getMessage()).build();
}
</code></pre>

<p>}
{% endcodeblock %}</p>

<p>The above turns a <code>CustomerNotFoundException</code> into the correct response code and adds a message to the response body. We encapsulate the <code>CustomerNotFoundException</code> by only allowing a single, narrow constructor.</p>

<p>{% codeblock lang:java %}
public class NotFoundException {</p>

<pre><code>public NotFound(Identifier identifier) {
    super(format("Could not find customer \"%s\"", identifier));
}
</code></pre>

<p>}
{% endcodeblock %}</p>

<p>Then we can complete the task by defining a default exception handler to turn any unexpected exceptions into an internal server errors (HTTP <code>500</code>).</p>

<p>{% codeblock lang:java %}
@Provider
public class RuntimeExceptionMapper implements ExceptionMapper<Throwable> {</p>

<pre><code>public Response toResponse(Throwable exception) {
    return Response.status(500).entity(exception).build();
}
</code></pre>

<p>}
{% endcodeblock %}</p>

<p>With this addition, we've implemented our system wide policy. All exceptions will be handled consistently thanks to the class hierarchy of <code>Throwable</code>.</p>

<h2>The Database Transaction Boundary</h2>

<p>When we're performing various database interactions in the context of a business operation, we'll likely want to maintain atomicity in the event of one of the interactions failing. The typical example is a bank account transfer. We'll credit one account then debit the other. If something goes wrong, we want to rollback. Otherwise we'd be left in an inconsistent state.</p>

<p>Database transactions are the typical solution to this class of problem. We'll like to start a transaction and perform some <em>unit of work</em> before finally committing. If a problem occurs during the execution, we should rollback. We don't want to do this ad-hoc with various catch statements. If we did, it would be hard to manage and to be sure we've got all the cases. We could even 'double up' and handle exceptions twice.</p>

<p>So for the <em>when</em>, unlike the declarative examples above, we can put a more imperative mechanism in place and ensure all database work uses the method below.</p>

<p>{% codeblock lang:java %}
public &lt;T, E extends Exception> T run(UnitOfWork&lt;T, E> unitOfWork) throws Throwable {</p>

<pre><code>Session session = sessionProvider.getCurrentSession();
Transaction transaction = session.beginTransaction();
try {
    T result = unitOfWork.execute(sessionProvider);
    transaction.commit();
    return result;
} catch (Throwable e) {
    transaction.rollback();
    throw e;
} finally {
    if (session.isOpen())
        session.close();
}
</code></pre>

<p>}
{% endcodeblock %}</p>

<p>This also describes the <em>how</em>. We've chosen to handle the exception by rolling back the transaction and interestingly, rethrowing the exception. Although we've identified this database interaction as a boundary, by rethrowing the exception, we're recognising that there are additional boundaries to consider. In the context of a database call, for example, the exception could propagate up to the UI. We've handled the exception here to maintain data integrity <em>and</em> allowed other exception handling policies to be applied. It's a good example of an <em>internal boundary</em>.</p>

<p>For example; two sales clerks try and update a customer's details at the same time in their web app causing a conflict. Hibernate detects the problem and throws a <code>OptimisticLockException</code>. Our database exception handling policy kicks in to rollback one of the transactions. It rethrows the exception which the web app redirects to an error page listing the diff and allowing the user to merge and retry.</p>

<p>See a <a href="{{%20root_url%20}}/blog/2012/01/29/transaction-management-without/">previous article</a> for more details about this kind of approach to transaction management.</p>

<h2>Some Parting Tips</h2>

<p>We've talked about a lot here. Hopefully, the examples demonstrate the idea and here's a few parting tips.</p>

<ul>
<li>Identify the boundaries (and so <em>when</em> to handle).</li>
<li>Define a general handling approach for each boundary (<em>how</em> to handle).</li>
<li>Application specific exception subclasses should be <em>specialised</em>.</li>
<li>Exceptions are objects too; think OO.</li>
<li>Never catch an exception and rethrow verbatim.</li>
<li>However, if required, do <em>translate</em> an exception into another <em>only</em> at the boundaries.</li>
<li>Don't forget that boundaries can be internal, just be explicit about where they are.</li>
</ul>


<p>To see an example of more specialism in exception-types, see the next article <a href="{{%20root_url%20}}/blog/2012/03/29/building-better-exceptions/">Building Better Exceptions</a>.</p>

<p>Remember though, there is no spoon. Feel free to discard these tips if they don't apply. After all, you may have different constraints or you may just know better.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Expecting Exceptions JUnit Rule]]></title>
    <link href="http://baddotrobot.com/blog/2012/03/27/expecting-exception-with-junit-rule/"/>
    <updated>2012-03-27T00:00:00+01:00</updated>
    <id>http://baddotrobot.com/blog/2012/03/27/expecting-exception-with-junit-rule</id>
    <content type="html"><![CDATA[<p>To make an assertion that an exception was thrown with JUnit, it's fairly common to use the try/fail/catch idiom or
the <code>expected</code> element of the <code>@Test</code> annotation. Despite being more concise than the former,
there is an argument that using <code>expected</code> doesn't support all the cases you may want to test. The example being
to perform additional testing after the exception or testing against the actual exception message.</p>

<p>JUnit 4.7 introduces the next progression, a <code>@Rule</code> that offers the best of both worlds. This articles weighs up the pros and cons of each approach and takes a closer look at the syntax of each.</p>

<!-- more -->


<h2>The try/fail/catch Idiom</h2>

<p>The typical pattern is to catch an exception or fail explicitly if it was never thrown.</p>

<p>{% codeblock lang:java %}
@Test
public void example1() {</p>

<pre><code>try {
    find("something");
    fail();
} catch (NotFoundException e) {
    assertThat(e.getMessage(), containsString("could not find something"));
}
// ... could have more assertions here
</code></pre>

<p>}
{% endcodeblock %}</p>

<p>which would highlight a failure in the following way.</p>

<pre><code>java.lang.AssertionError: expected an exception
    at org.junit.Assert.fail(Assert.java:91)
    at bad.roboot.example.ExceptionTest.example1(ExceptionTest.java:20)
    ...
</code></pre>

<p>The idiom has potential advantages in that it offers the opportunity to assert against the actual exception as well as performing additional work after the expectation. Aside from the noise, the major drawback however is that its very easy to forget to include the <code>fail</code> call. If genuinely doing test first, where we always run the test red, this wouldn't be a problem but all too often things slip through the net. In practice, I've seen far too many examples with a missing <code>fail</code> giving false positives.</p>

<h2>@Test (expected = Exception.class)</h2>

<p>Using the <code>expected</code> element, we can rewrite the test as follows.</p>

<p>{% codeblock lang:java %}
@Test (expected = NotFoundException.class)
public void example2() throws NotFoundException {</p>

<pre><code>find("something");
// ... this line will never be reached when the test is passing
</code></pre>

<p>}
{% endcodeblock %}</p>

<p>which will result in the following failure.</p>

<pre><code>java.lang.AssertionError: Expected exception: bad.robot.example.NotFoundException
</code></pre>

<p>Much more concise, we've done away with all the noise at the cost of not being able to assert against the exception
message. We've also lost the ability to make more assertions after <code>find</code>. However, you might decide that smaller focused tests are in fact a good thing. Using this syntax, we're lead into writing a test focused on just one thing; that an exception is thrown when we call <code>find</code>.</p>

<p>The test feedback has also become clearer.</p>

<h2>ExpectedException Rule</h2>

<p>Using an instance of <code>ExpectedException</code>, we can define a <a href="http://www.infoq.com/news/2009/07/junit-4.7-rules">JUnit rule</a>
that allows us to setup expectations that are checked after the test concludes. It has a similar feel to
setting up expectations in mocking frameworks like <a href="http://www.jmock.org">JMock</a>.</p>

<p>{% codeblock lang:java %}
@Rule public ExpectedException exception = ExpectedException.none();</p>

<p>@Test
public void example3() throws NotFoundException {</p>

<pre><code>exception.expect(NotFoundException.class);
exception.expectMessage(containsString("exception message"));
find("something");
// ... this line will never be reached when the test is passing
</code></pre>

<p>}
{% endcodeblock %}</p>

<p>Which would show the failure below.</p>

<pre><code>java.lang.AssertionError: Expected test to throw (exception with message a string containing "exception message" and an instance of bad.robot.example.NotFoundException)
    at org.junit.rules.ExpectedException$ExpectedExceptionStatement.evaluate(ExpectedException.java:118)
    ...
</code></pre>

<p>The rule allows us to assert the exception is thrown and make assertions against the message. We still can't make
additional assertions after the <code>find</code> method call, but this may not be a bad thing.</p>

<h2>Beware combining Rules with @RunWith</h2>

<p>Beware though that if you combine the rule with certain <code>@RunWith</code> classes,
you may get a false positive. Specifically, if you were to run with a class that extends <code>JUnit4ClassRunner</code> in the
above example, the test would no longer fail. You'd get a false positive.</p>

<p>For example, if you're using a version of JMock prior to 2.6.0 and use <code>@RunWith(JMock.class)</code> you'll encounter this. Older versions of the <code>JMock.class</code> extend <code>JUnit4ClassRunner</code> and <code>JUnit4ClassRunner</code> ignores rules. The newer <code>BlockJUnit4ClassRunner</code> supports rules and JMock post 2.6.0 extends this class in <code>JMock.class</code>.</p>

<h2>Summary</h2>

<p>The new rule offers a balance between concise syntax and function. In practice though if you're not interested in asserting against the exception's message, the <code>expected</code> element offers the most straight forward syntax. In the next article <a href="{{%20root_url%20}}/blog/2012/03/28/exception-handling-as-a-system-wide-concern/">Exception Handling as a System Wide Concern</a>, I describe a general exception handling approach which negates the need to assert against exception messages.</p>

<p>The <code>ExpectedException</code> rule comes with its own baggage. The declarative nature of the rule means <em>magic</em> just happens and so there is a new kind of "noise" to cope with in the test. You may or may not be comfortable with this.</p>

<p>I'd love to hear which approach you prefer, so feel free to post a comment below.</p>

<div>
    <script type="text/javascript">
    function trackOutboundLink(link, category, action) {

        try {
            _gaq.push(['_trackEvent', category , action]);
        } catch(err){}

        setTimeout(function() {
            document.location.href = link.href;
        }, 100);
    }
    </script>
</div>


<p><a href="http://www.amazon.co.uk/gp/product/0974514012/ref=as_li_ss_tl?ie=UTF8&camp=1634&creative=19450&creativeASIN=0974514012&linkCode=as2&tag=baddotrobot-21" onClick="trackOutboundLink(this, 'Outbound Links', 'amazon.com'); return false;">{% img right http://ecx.images-amazon.com/images/I/41t9iO0egKL.<em>SL160</em>.jpg 'Pragmatic Unit Testing in Java with Junit (Pragmatic Programmers)' %}</a></p>

<p><a href="http://www.amazon.co.uk/gp/product/0321503627/ref=as_li_ss_il?ie=UTF8&camp=1634&creative=19450&creativeASIN=0321503627&linkCode=as2&tag=baddotrobotco-21" onClick="trackOutboundLink(this, 'Outbound Links', 'amazon.com'); return false;">{% img right http://ws.assoc-amazon.co.uk/widgets/q?<em>encoding=UTF8&amp;ASIN=0321503627&amp;Format=</em>SL160_&amp;ID=AsinImage&amp;MarketPlace=GB&amp;ServiceVersion=20070822&amp;WS=1&amp;tag=baddotrobotco-21 'Growing Object Oriented Software' %}</a></p>

<h2>Recommended Reading</h2>

<ul>
<li><a href="http://www.amazon.co.uk/gp/product/0974514012/ref=as_li_ss_tl?ie=UTF8&camp=1634&creative=19450&creativeASIN=0974514012&linkCode=as2&tag=baddotrobot-21" onClick="trackOutboundLink(this, 'Outbound Links', 'amazon.com'); return false;">Pragmatic Unit Testing in Java with Junit (Pragmatic Programmers)</a>, Andy Hunt, Dave Thomas</li>
<li><a href="http://www.amazon.co.uk/gp/product/0321503627/ref=as_li_ss_tl?ie=UTF8&camp=1634&creative=19450&creativeASIN=0321503627&linkCode=as2&tag=baddotrobot-21" onClick="trackOutboundLink(this, 'Outbound Links', 'amazon.com'); return false;">Growing Object-Oriented Software, Guided by Tests</a>, Steve Freeman, Nat Pryce</li>
<li><a href="http://www.amazon.co.uk/gp/product/1932394850/ref=as_li_ss_tl?ie=UTF8&camp=1634&creative=19450&creativeASIN=1932394850&linkCode=as2&tag=baddotrobot-21" onClick="trackOutboundLink(this, 'Outbound Links', 'amazon.com'); return false;">Test Driven: TDD and Acceptance TDD for Java Developers</a>, Lasse Koskela</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Catching Multiple Exceptions (and rethrowing them all!)]]></title>
    <link href="http://baddotrobot.com/blog/2011/08/29/catching-multiple-exceptions-and/"/>
    <updated>2011-08-29T00:00:00+01:00</updated>
    <id>http://baddotrobot.com/blog/2011/08/29/catching-multiple-exceptions-and</id>
    <content type="html"><![CDATA[<p>Sometimes, we may want to catch an exception, temporarily ignoring it to continue work before rethrowing it when its more appropriate to do so. I recently saw a slight variation of this whereby the developer wanted to (potentially) catch multiple exceptions, perform some processing then throw. However, it left the question that if more than one was caught, which exception should we actually rethrow. We certainly don't want to loose any information and should really allow the client to catch the exception in a standard way.</p>

<p>This got me thinking about how we should deal with this kind of thing. In the end, I came up with the idea of a collection class to capture the <code>Exceptions</code> and a sub-class of <code>Exception</code> to represent an exception containing other, embedded exceptions. When you're done collecting exceptions, you can just check and rethrow as a new exception type.</p>

<!-- more -->


<p>For example, the domain cleaning class below can throw an exception during the <code>deleteAll</code> method. Rather than abandon the cleanup of subsequent objects, we can employ this tactic to continue the cleanup and throw an exception containing the underlying problems when we're done.</p>

<p>{% codeblock lang:java %}
public class DomainCleaner {</p>

<pre><code>public static void clean(Domain domain) throws CompositeException {
    Exceptions exceptions = new Exceptions();
    clean(domain.customers(), exceptions);
    clean(domain.suppliers(), exceptions);
    clean(domain.invoices(), exceptions);
    exceptions.checkAndThrow();
}

private static void clean(Repository repository, Exceptions exceptions) {
    try {
        ((TestRepository) repository).deleteAll();
    } catch (RepositoryException e) {
        exceptions.add(e);
    }
}
</code></pre>

<p>}
{% endcodeblock %}</p>

<p>We simply add to the exception collection class (<code>exceptions.add(e)</code>) and then when we're done, we can check it and throw a composite exception if needed with <code>exceptions.checkAndThrow()</code>.</p>

<p>So far, we've only been interested in the fact that multiple exception can be handled and so haven't needed to programmatically query for specific exception types. For example, we've only needed this up until now.</p>

<p>{% codeblock lang:java %}
try {
   // ... something that calls checkAndThrow()
} catch (CompositeException e) {
   // ... this is enough for now
}
{% endcodeblock %}</p>

<p>The details of the classes are below.</p>

<p>{% codeblock lang:java %}
public class Exceptions implements java.lang.Iterable<Exception> {</p>

<pre><code>private final List&lt;Exception&gt; exceptions = new ArrayList&lt;Exception&gt;();

public void add(Exception exception) {
    exceptions.add(exception);
}

@Override
public Iterator&lt;Exception&gt; iterator() {
    return exceptions.iterator();
}

public void checkAndThrow() throws CompositeException {
    if (!exceptions.isEmpty())
        throw new CompositeException(this);
}
</code></pre>

<p>}
{% endcodeblock %}</p>

<p>The <code>toString()</code> implementation below outputs the embedded exceptions in a way that is consistent with how you'd expect to see regular exceptions.</p>

<p>{% codeblock lang:java %}
public class CompositeException extends Exception {</p>

<pre><code>private final Exceptions exceptions;

public CompositeException(Exceptions exceptions) {
    super("composite exception was thrown with embedded exceptions (see details)");
    this.exceptions = exceptions;
}

@Override
public String toString() {
    StringBuilder builder = new StringBuilder();
    for (Exception exception : exceptions)
        builder.append('\t').append(new ExceptionToString(exception).toString()).append('\n');
    return String.format("%s\n{composite exceptions=\n%s}\n%s", this.getClass().getName(), builder.toString(), super.toString());
}
</code></pre>

<p>}
{% endcodeblock %}</p>
]]></content>
  </entry>
  
</feed>

<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: scala | bad.robot]]></title>
  <link href="http://baddotrobot.com/blog/categories/scala/atom.xml" rel="self"/>
  <link href="http://baddotrobot.com/"/>
  <updated>2016-03-30T18:28:43+01:00</updated>
  <id>http://baddotrobot.com/</id>
  <author>
    <name><![CDATA[Toby Weston]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Implicit Functions in Scala]]></title>
    <link href="http://baddotrobot.com/blog/2015/07/14/scala-implicit-functions/"/>
    <updated>2015-07-14T18:42:00+01:00</updated>
    <id>http://baddotrobot.com/blog/2015/07/14/scala-implicit-functions</id>
    <content type="html"><![CDATA[<p>In the <a href="{{%20root_url%20}}/blog/2015/07/03/scala-implicit-parameters/">previous post</a>, we looked at implicit parameters; parameters that will be automatically passed values annotated as <code>implicit</code>. In this post, we'll take a look at implicit functions and how they can be useful to convert things of one type to things of another.</p>

<!-- more -->


<h2>Implicit Functions</h2>

<p>Implicit functions will be called automatically if the compiler thinks it's a good idea to do so. What that means is that if your code doesn't compile but would, if a call was made to an implicit function, Scala will call that function to make it compile. They're typically used to create <em>implicit conversion functions</em>; single argument functions to automatically convert from one type to another.</p>

<p>For example, the following function allows you to convert a Scala function into a instance of the Java 8 <code>Consumer</code> <a href="{{%20root_url%20}}/blog/2014/04/07/functional-interfaces-in-java8/">single argument method</a> but still use Scala's concise syntax.</p>

<p>{% codeblock lang:scala %}
implicit def toConsumer<a href="function:%20A%20=>%20Unit">A</a>: Consumer[A] = new Consumer<a href="">A</a> {
  override def accept(arg: A): Unit = function.apply(arg)
}
{% endcodeblock %}</p>

<p>You can avoid having to write clunky anonymous class instantiation when interfacing with Java and so mimic Java's lambda syntax. So rather than having to use the longhand version like this.</p>

<p>{% codeblock lang:scala %}
def exampleUsingJavaForEach() {
  javaCollection.forEach(new Consumer<a href="">Element</a> {</p>

<pre><code>override def accept(element: Element): Unit = observer.update
</code></pre>

<p>  })
}
{% endcodeblock %}</p>

<p>You can write this, where we just pass a Scala function to Java's <code>forEach</code> method.</p>

<p>{% codeblock lang:scala %}
def exampleUsingImplicitConversion() {
  javaCollection.forEach((element: Element) => observer.update)
}
{% endcodeblock %}</p>

<p>The argument to <code>forEach</code> is actually a function of type <code>Element =&gt; Unit</code>. Scala recognises that the <code>toConsumer</code> method could convert this into a <code>Consumer[Element]</code> and does so implicitly.</p>

<p>{% codeblock lang:scala %}
def exampleUsingImplicitConversion() {
  val function: ObserverS => Unit = (observer) => observer.update
  javaCollection.forEach(function)
}
{% endcodeblock %}</p>

<p>Which is basically short-hand for this.</p>

<p>{% codeblock lang:scala %}
def exampleUsingImplicitConversion() {
  val function: ObserverS => Unit = (observer) => observer.update(this, status)
  javaCollection.forEach(toConsumer(function))
}
{% endcodeblock %}</p>

<h2>Another Example</h2>

<p>If we have a button on we web page that we'd like to find using <a href="http://www.seleniumhq.org/projects/webdriver/">Web Driver</a>, we'd normally write something like the following, using a "locator" to locate it by <code>id</code> attribute.</p>

<p>{% codeblock lang:scala %}
  val button: WebElement = driver.findElement(By.id("save-button")
  button.click()
{% endcodeblock %}</p>

<p>It doesn't take into account that the element might not be there when we call it (for example, when our UI uses ajax and adds the button asynchronously) and it's also a bit verbose. We can use an implicit function to address both of these issues.</p>

<p>The fragment below uses the <a href="https://selenium.googlecode.com/git/docs/api/java/index.html?org/openqa/selenium/support/ui/WebDriverWait.html"><code>WebDriverWait</code></a> class to wait for a UI element to appear on the screen (using <code>findElement</code> to check and retrying if necessary) and so smooths out the asynchronous issues.</p>

<p>{% codeblock lang:scala %}
implicit def waitForElement(locator: By): WebElement = {
  val predicate: WebDriver => WebElement = _.findElement(locator)
  new WebDriverWait(driver, 30).withMessage(s"waiting for element '$locator' on page '${driver.getCurrentUrl}'").until(predicate)
}
{% endcodeblock %}</p>

<p>It's also an implicit function designed to convert a <code>By</code> locator into a <code>WebElement</code>. It means we can write something like the following where <code>button</code> is no longer a <code>WebElement</code>, but a <code>By</code>.</p>

<p>{% codeblock lang:scala %}
  val button = By.id("save-button")
  button.click()
{% endcodeblock %}</p>

<p>Without the implicit <code>waitForElement</code> function, the code wouldn't compile; <code>By</code> doesn't have a <code>click</code> method on it. With the implicit function in scope however, the compiler works out that calling it (and passing in <code>create</code> as the argument), would return something that <em>does</em> have the <code>click</code> method and would compile.</p>

<h2>Single Arguments Only Please</h2>

<p>Now there's one little bit I've brushed over here; namely how the <code>WebDriver</code> <code>driver</code> instance is made available. The example above assumes it's available but it'd be nicer to pass it into the function along with <code>locator</code>. However, there's a restriction of passing only a single argument into an implicit function. The answer is to use a second argument (using Scala's built in <a href="{{%20root_url}}/blog/2013/07/21/curried-functions/">currying support</a>). By combining implicit parameters the we saw in the <a href="{{%20root_url%20}}/blog/2015/07/03/scala-implicit-parameters/">previous post</a>, we can maintain the elegant API.</p>

<p>{% codeblock lang:scala %}
implicit def waitForElement(locator: By)(implicit driver: WebDriver: WebElement = {
  val predicate: WebDriver => WebElement = _.findElement(locator)
  new WebDriverWait(driver, 30).withMessage(s"waiting for element '$locator' on page '${driver.getCurrentUrl}'").until(predicate)
}
{% endcodeblock %}</p>

<p>So the full example would look like this; making <code>driver</code> an implicit <code>val</code> means we can avoid a call to <code>button.click()(driver)</code>.</p>

<p>{% codeblock lang:scala %}
class ExampleWebDriverTest extends mutable.Specification {</p>

<p>  implicit val driver: WebDriver = Browser.create.driver</p>

<p>  "The 'save' button writes to the database" >> {</p>

<pre><code>val button = By.id("save")

// scala calls the implicit def to convert the button into a WebElement
button.click()        
// ...
</code></pre>

<p>  }
}
{% endcodeblock %}</p>

<h2>Roundup</h2>

<p>You can see from the examples above that implicit functions (and often combining them with implicit values) can make for succinct and more readable APIs. Next we'll look at implicit classes.</p>

<p>If you're interested in more Java bridge implicits like <code>toConsumer</code>, check out this <a href="https://gist.github.com/tobyweston/0fbb8eb114db48596e6b">gist</a>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Implicit Parameters in Scala]]></title>
    <link href="http://baddotrobot.com/blog/2015/07/03/scala-implicit-parameters/"/>
    <updated>2015-07-03T18:42:00+01:00</updated>
    <id>http://baddotrobot.com/blog/2015/07/03/scala-implicit-parameters</id>
    <content type="html"><![CDATA[<p>Scala "implicits" allow you to omit calling methods or referencing variables directly but instead rely on the compiler to make the connections for you. For example, you could write a function to convert from and <code>Int</code> to a <code>String</code> and rather than call that function <em>explicitly</em>, you can ask the compiler to do it for you, <em>implicitly</em>.</p>

<p>In the next few posts, we'll look at the different types of implicit bindings Scala offers and show some examples of when they can be useful.</p>

<!-- more -->


<p>There are three categories of "implicits";</p>

<ol>
<li><strong><a href="{{%20root_url%20}}/blog/2015/07/03/scala-implicit-parameters/">Implicit parameters</a></strong> (aka implicit values) will be automatically passed values that have been marked as <code>implicit</code></li>
<li><strong><a href="{{%20root_url%20}}/blog/2015/07/14/scala-implicit-functions/">Implicit functions</a></strong> are <code>def</code>s that will be called automatically if the code wouldn't otherwise compile</li>
<li><strong>Implicit classes</strong> extend behaviour of existing classes you don't otherwise control (akin to <a href="https://developer.apple.com/library/prerelease/ios/documentation/Cocoa/Conceptual/ProgrammingWithObjectiveC/CustomizingExistingClasses/CustomizingExistingClasses.html">categories</a> in Objective-C)</li>
</ol>


<!-- more -->


<h2>Implicit Parameters</h2>

<p>At it's simplest, an implicit parameter is just a function parameter annotated with the <code>implicit</code> keyword. It means that if no value is supplied when called, the compiler will look for an implicit value and pass it in for you.</p>

<p>{% codeblock lang:scala %}
def multiply(implicit by: Int) = value * by
{% endcodeblock %}</p>

<p>You tell the compiler what it can pass in implicitly but annotating values with <code>implicit</code></p>

<p>{% codeblock lang:scala %}
implicit val multiplier = 2
{% endcodeblock %}</p>

<p>and call the function like this</p>

<p>{% codeblock lang:scala %}
multiply
{% endcodeblock %}</p>

<p>The compiler knows to convert this into a call to <code>multiply(multiplier)</code>. If you forget to define an implicit <code>var</code>, you'll get an error like the following.</p>

<pre><code>error: could not find implicit value for parameter by: Int
       multiply
       ^
</code></pre>

<h2>Implicit <code>val</code>, <code>var</code> or <code>def</code></h2>

<p>You can ask the compiler to call your function with an implicit <code>val</code> (like we've just seen), a <code>var</code> or even another <code>def</code>. So, we could have written a function that returns an <code>Int</code> and Scala would attempt to use that instead.</p>

<p>{% codeblock lang:scala %}
implicit def f: Int = if (monday) 4 else 2
{% endcodeblock %}</p>

<p>The compiler would try to resolve this as <code>multiply(f())</code>.</p>

<p>However, you can't have more than one in scope. So if we have both the <code>multipler</code> value and <code>f</code> function defined as implicit and call <code>multiply</code>, we'd get the following error.</p>

<pre><code>error: ambiguous implicit values:
 both value multiplier of type =&gt; Int
 and method f of type =&gt; Int
 match expected type Int
       multiply
       ^
</code></pre>

<h2>Syntax</h2>

<p>You can only use <code>implicit</code> once in a parameter list and all parameters following it will be implicit. For example;</p>

<p>{% codeblock lang:scala %}
def example1(implicit x: Int)                       // x is implicit
def example2(implicit x: Int, y: Int)               // x and y are implicit
def example3(x: Int, implicit y: Int)               // wont compile
def example4(x: Int)(implicit y: Int)               // only y is implicit
def example5(implicit x: Int)(y: Int)               // wont compile
def example6(implicit x: Int)(implicit y: Int)      // wont compile
{% endcodeblock %}</p>

<h2>Example</h2>

<p>As an example, the test below uses <a href="http://www.seleniumhq.org/projects/webdriver/">Web Driver</a> (and specifically an instance of the <code>WebDriver</code> class) to check that a button is visible on screen. The <code>beVisible</code> method creates a <code>Matcher</code> that will check this for us but rather than pass in the <code>driver</code> instance explicitly, it uses an implicit <code>val</code> to do so.</p>

<p>{% codeblock lang:scala %}
class ExampleWebDriverTest extends mutable.Specification {</p>

<p>  implicit val driver: WebDriver = Browser.create.driver</p>

<p>  "The checkout button is visible" >> {</p>

<pre><code>val button = By.id("checkout")
// ...
button must beVisible           // reads better than 'must beVisible(driver)'   
</code></pre>

<p>  }</p>

<p>  def beVisible(implicit driver: WebDriver): Matcher[By] = new Matcher[By] {</p>

<pre><code>def apply[S &lt;: By](t: Expectable[S]) = result(
  t.value.isDisplayed,
  s"${t.value.toString} is visible",
  s"${t.value.toString} is not visible",
  t)
</code></pre>

<p>  }
}
{% endcodeblock %}</p>

<h2>Roundup</h2>

<p>Implicit parameters are useful for removing boiler plate parameter passing and can make your code more readable. So if you find yourself passing the same value several times in quick succession, they can help hide the duplication.</p>

<p>The Scala library often use them to define default implementations that are "just available". When you come to need a custom implementation, you can pass one in explicitly or use your own implicit value. A good example here is the <code>sorted</code> method on <a href="http://www.scala-lang.org/api/2.11.7/#scala.collection.SeqLike"><code>SeqLike</code></a> class.</p>

<p>The really useful stuff though comes when we combine implicit parameters with the other types of "implicits". Read more in the series to build up a picture.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JMock to Scalamock Cheat Sheet]]></title>
    <link href="http://baddotrobot.com/blog/2015/05/09/jmock-to-scalamock-cheatsheet/"/>
    <updated>2015-05-09T12:41:00+01:00</updated>
    <id>http://baddotrobot.com/blog/2015/05/09/jmock-to-scalamock-cheatsheet</id>
    <content type="html"><![CDATA[<p>An abbreviated set of JMock examples with their Scalamock equivalents.</p>

<!-- more -->


<h2>Mock Objects &amp; the "Context"</h2>

<p>{% codeblock lang:java Mocks and Mockery: Java / JMock %}
private final Mockery context = new JUnit4Mockery();</p>

<p>private final ScheduledExecutorService executor = context.mock(ScheduledExecutorService.class);
private final ScheduledFuture future = context.mock(ScheduledFuture.class);
{% endcodeblock %}</p>

<p>{% codeblock lang:scala Mocks and Mockery: Scala / Scalamock &amp; Specs2 %}
"A test with a mock context in scope" in new MockContext {
  val executor = mock[ScheduledExecutorService]<br/>
  val future = mock[ScheduledFuture[Any]]
  // ...
}
{% endcodeblock %}</p>

<h2>Returns</h2>

<p>{% codeblock lang:java Return a value: Java / JMock %}
context.checking(new Expectations() {{ braces }}</p>

<pre><code>oneOf(executor).shutdownNow(); will(returnValue(asList(waiting)));
oneOf(waiting).cancel(true);
</code></pre>

<p>}});
{% endcodeblock %}</p>

<p>{% codeblock lang:scala Return a value: Scala / Scalamock %}
(executor.shutdownNow <em>).expects().returning(asList(waiting)).once
(waiting.cancel </em>).expects(true).once
{% endcodeblock %}</p>

<p><strong>Notes:</strong></p>

<ul>
<li><code>expects()</code> is required for zero argument method call expectations.</li>
<li>You can leave off <code>once</code>; it will default to the same behaviour</li>
</ul>


<h2>Allowing / Ignoring</h2>

<p>{% codeblock lang:java Allowing: JMock / Java %}
context.checking(new Expectations() {{ braces }}</p>

<pre><code>allowing(executor).scheduleWithFixedDelay(with(any(Runnable.class)), with(any(Long.class)), with(any(Long.class)), with(any(TimeUnit.class))); will(returnValue(future));
oneOf(future).cancel(true);
</code></pre>

<p>}});
{% endcodeblock %}</p>

<p>{% codeblock lang:scala Allowing: Scalamock / Scala %}
(executor.scheduleWithFixedDelay <em>).expects(<em>, </em>, * , *).returning(future)
(future.cancel </em>).expects(true).once
{% endcodeblock %}</p>

<p><strong>Notes:</strong></p>

<ul>
<li>You could also add <code>.anyNumberOfTimes</code> after the <code>returning</code> call but it's unnecessary.</li>
<li>There's no way to distinguish the <em>intention</em> of allowing and ignoring interactions in Scalamock.</li>
</ul>


<h2>Default Values</h2>

<p>JMock will return a default value (as a dynamic proxy) if you set up an expectation but leave off a <code>returnValue</code>. In the example below, we don't care if it returns anything so if the code under test relies on a value, but the test does not, we don't have to express anything in the test.</p>

<p>{% codeblock lang:java Default Values: JMock / Java %}
oneOf(factory).create();
{% endcodeblock %}</p>

<p>If the underlying code were to check, say, that the result of <code>factory.create()</code> was not an empty list with <code>if (result.isEmpty())</code>, JMock would return something sensible and we'd avoid a <code>NullPointerException</code>. You might argue that this side affect should be captured in a test but leaving it off makes the intention of expectation clearer; we only care that <code>create</code> is called, not what it returns.</p>

<p>Scalamock will return <code>null</code> by default. So the above example would give a <code>NullPointerException</code> and you're required to do something like this. Notice we're using a <code>stub</code> and not a <code>mock</code> here.</p>

<p>{% codeblock lang:scala Default Values: Scalamock / Scala %}
val result = stub[Result]
(factory.create _).expects().once.returning(List(result))</p>

<p>{% endcodeblock %}</p>

<h2>Any / Wildcards</h2>

<p>JMock uses <code>with</code> and Hamcrest the matcher <code>IsAnything</code> (<code>any</code>) to match anything. The type is used by the compiler.</p>

<p>{% codeblock lang:java Any: JMock / Java %}
context.checking(new Expectations() {{ braces }}</p>

<pre><code>ignoring(factory).notifyObservers(with(any(SomeException.class)));
oneOf(factory).notifyObservers(with(any(AnotherException.class)));
</code></pre>

<p>}}
{% endcodeblock %}</p>

<p>In the Scala version, use a <a href="http://docs.scala-lang.org/style/types.html#ascription">type ascription</a> to give the compiler a hand in the partially applied method call;</p>

<p>{% codeblock lang:scala Any: Scalamock / Scala %}
(factory.notifyObservers(<em>: SomeException)).expects(*).anyNumberOfTimes
(factory.notifyObservers(</em>: SomeException)).expects(*).once
{% endcodeblock %}</p>

<p><strong>Notes:</strong></p>

<ul>
<li><code>AnotherException</code> is a subtype of <code>SomeException</code> but <code>any</code> will match on literally anything. Using subtypes like this in JMock is a bit of a smell as a test won't fail if a different subtype is thrown at runtime. It may be useful to express intent.</li>
<li><a href="http://stackoverflow.com/questions/30162263/scalamock-wildcard-argument-match-on-subtype">You can't replicate the subtype line</a> in Scalamock; (<code>(factory.notifyObservers(_: AnotherException))</code> doesn't compile.</li>
</ul>


<h2>Throwing Exceptions</h2>

<p>{% codeblock lang:java Exception: JMock / Java %}
final Exception exception = new RuntimeException();
context.checking(new Expectations() {{ braces }}</p>

<pre><code>oneOf(factory).create(); will(throwException(exception));
oneOf(factory).notifyObservers(exception);
</code></pre>

<p>}});
{% endcodeblock %}</p>

<p>{% codeblock lang:scala Exception: Scalamock / Scala %}
val exception = new Exception
(factory.create <em>).expects().throws(exception).once
(factory.notifyObservers(</em>: Exception)).expects(exception).once</p>

<p>{% endcodeblock %}
<strong>Notes:</strong></p>

<ul>
<li>In Scalamock, <code>throws</code> and <code>throwing</code> are interchangeable.</li>
<li>Again, <code>once</code> is optional.</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Scala Learning Curve]]></title>
    <link href="http://baddotrobot.com/blog/2014/11/25/scala-learning-curve/"/>
    <updated>2014-11-25T07:09:00+00:00</updated>
    <id>http://baddotrobot.com/blog/2014/11/25/scala-learning-curve</id>
    <content type="html"><![CDATA[<p>If you've just started to learn Scala and are wondering what to expect, it's typical to experience a quick ramp up in skill followed by a slower adoption of the more sophisticated features. In this post, I talk about what I think of as a typical learning curve.</p>

<p>{% img center ../../../../../images/learning_curve.png 752 389 %}</p>

<p>Taken from my <a href="http://bit.ly/1DsYl9f">Pluralsight</a> course, the chart shows experience (or time) along the <code>x</code> axis and some measure of "learning" on the <code>y</code>.</p>

<!-- more -->


<h2>Milestone 1</h2>

<p>When you first start, you can expect getting up to speed with the language to be a fairly steep incline. That's not to say that it's difficult to get to the first plateau, so by "steep", I really mean "short"; you can expect a relatively quick increment in learning.</p>

<p>You'll probably sit here for a bit applying what you've learnt. I see this as the first milestone; to be able to build object-oriented or imperative applications using language specific constructs and features but without necessarily adopting functional programming. Just like learning any other language in the Java / C family.</p>

<h2>Milestone 2</h2>

<p>I see the next milestone as adopting functional programming techniques.</p>

<p>This is much more challenging and likely to be a shallower curve. Typically this will involve using traditional architecture design but implementing functional programming techniques in the small. You can think of this approach as <a href="http://www.johndcook.com/blog/2009/03/23/functional-in-the-small-oo-in-the-large/">"functional in the small, OO in the large"</a>. Starting to embrace a new functional way of thinking and unlearning some of the traditional techniques can be hard, hence the shallower incline.</p>

<p>Concrete examples here are more than just language syntax, so things like <a href="http://baddotrobot.com/blog/2012/04/03/scala-as-a-functional-oo-hybrid/">higher order and pure functions</a>, <a href="http://en.wikipedia.org/wiki/Referential_transparency_(computer_science)">referential transparency</a>, immutability and side-affect free, more declarative coding; all the things that are typically offered by <a href="http://en.wikipedia.org/wiki/Pure_function">pure</a> functional languages. <strong>The key thing here is that they're applied in small, isolated areas.</strong></p>

<h2>Milestone 3</h2>

<p>The next challenge is working towards a more cohesive functional design; this really means adopting a functional style at a system level; architecting the entire application as functions and abandoning the object-oriented style completely. So, aiming for something like a Haskell application.</p>

<p>All the concrete functional programming mechanisms above apply but this time, throughout the system; not to isolated areas but lifted to application-wide concerns. Picking up advanced libraries like <a href="http://eed3si9n.com/learning-scalaz/index.html">Scalaz</a> seems to go hand-in-hand with this point of the curve.</p>

<h2>As a Continuum</h2>

<p>You can also think of adoption as more of a continuum with traditional imperative programming on the left and pure functionally programming on the right.</p>

<p>{% img center ../../../../../images/continuum.png 591 368 %}</p>

<p>You can think of the far right as Haskell on the JVM. Haskell is a pure functional language so you don't have any choice but to design your app in a functional way. Scala is an object-oriented / functional hybrid, it can only give you the tools. It can't enforce functional programming; you need discipline and experience in Scala to avoid mutating state for example. Haskell will physically stop you.</p>

<p>So as you start out on the continuum using Java and move to the right, libraries like <a href="http://www.functionaljava.org/">Functional Java</a>, <a href="https://code.google.com/p/totallylazy/">Totally Lazy</a> and even <a href="https://leanpub.com/whatsnewjava8">Java 8 features</a> help you adopt a more functional style. There comes a point where a language switch helps even more. Functional idioms become a <strong>language feature</strong> rather than a <strong>library feature</strong>. The syntactical sugar of for-comprehensions are a good example.</p>

<h2>Final Thoughts</h2>

<p>Libraries like <a href="http://eed3si9n.com/learning-scalaz/index.html">Scalaz</a> make it easier to a develop a purely functional style. It's worth noting that reaching the far right of the continuum (or top right quadrant of the learning curve) doesn't have to be the goal. There are plenty of teams operating effectively across the continuum.</p>

<p>When you're adopting Scala, make a deliberate decision about where you want to be on the continuum, be clear about <em>why</em> and use my learning curve as a way to gauge your progress.</p>

<p>I've developed a video course exclusively for <a href="http://bit.ly/1DsYl9f">Pluralsight</a> to help Java teams make the transition to Scala. If you're interested and liked this post, <a href="http://bit.ly/1DsYl9f">check it out</a> or read my book <a href="http://amzn.to/1M0w9jZ">Learn Scala for Java Developers</a>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Scala Mixins: The Right Way]]></title>
    <link href="http://baddotrobot.com/blog/2014/09/22/scala-mixins/"/>
    <updated>2014-09-22T06:09:00+01:00</updated>
    <id>http://baddotrobot.com/blog/2014/09/22/scala-mixins</id>
    <content type="html"><![CDATA[<p>Scala traits are interesting because they can be used for <a href="http://en.wikipedia.org/wiki/Polymorphism_(computer_science">inclusion polymorphism</a> <em>and</em> to <a href="http://en.wikipedia.org/wiki/Mixin">mixin</a> behaviour. I've found tension here though, as the former uses inheritance and the later is more about code re-use. So when a Scala class extends a trait with behaviour, it seems to go against the generally accepted view that using inheritance as a mechanism for code re-use <a href="http://baddotrobot.com/blog/2009/01/24/inheritance-vs-composition/">is a bad idea</a>.</p>

<p>It can be tricky not break the <a href="http://en.wikipedia.org/wiki/Composition_over_inheritance#Benefits">inheritance vs. composition</a> principle when using traits with behaviour. Is it clear to you when you might be?</p>

<!-- more -->


<h2>Mixins the Wrong Way</h2>

<p><a href="https://www.amazon.co.uk/Programming-Scala-Martin-Odersky/dp/0981531644/ref=as_sl_pc_ss_til?tag=baddotrobotco-21&amp;linkCode=w01&amp;linkId=DNXSQPP4AVLACD7U&amp;creativeASIN=0981531644">Odersky</a> calls traits with behaviour "mixin traits". To be a genuine mixin trait, it should be used to mixin behaviour and not just something you inherit from. But what's the difference? Let's look at an example.</p>

<p>Let's say that you have a <a href="http://martinfowler.com/eaaCatalog/repository.html">repository</a> style class who's API talks about business operations, a <code>Customers</code> class for example. You might have an database backed version and you don't want anything going behind your back and messing with the data; everything in production code should go through your business API.</p>

<p>{% codeblock lang:scala %}
class OracleCustomers {</p>

<pre><code>def add(customer: Customer) = { ... }
def getCustomer(id: CustomerId) = { ... }
def getBasketValue(query: CustomerQuery) = { ... }
def ship(query: CustomerQuery) = { ... }
</code></pre>

<p>}
{% endcodeblock %}</p>

<p>Now let's say that you want a test fixture to allow you to quickly setup test data in your <code>Customers</code> without having to go through the production API. You can provide an implementation to a trait and collect some data together like this;</p>

<p>{% codeblock lang:scala %}
trait BackdoorCustomers {                               // &lt;- bad name, this is really a "fixture"</p>

<pre><code>abstract val customers: Customers

def addSomeCustomersWithFullBaskets() = {
    customers.add(RandomCustomer().with(RandomFullBasket()))
    customers.add(RandomDiscountedCustomer().with(RandomFullBasket()))            
}

def addSomeCustomersWithEmptyBaskets() = {
    customers.add(RandomCustomer())
    customers.add(RandomExpiredCustomer())
}
</code></pre>

<p>}
{% endcodeblock %}</p>

<p>This says that extending classes must provide a value for <code>customers</code>. It implements some coarse grained test setup against <code>customers</code>. So when writing a test, it's easy to just extend the trait and slot in an implementation of <code>customers</code>. For example an <code>InMemoryCustomers</code> or an Oracle implementation that by-passes any constraint checking the proper API might enforce.</p>

<p>{% codeblock lang:scala %}
class OracleCustomerTest extends BackdoorCustomers {</p>

<pre><code>override val customers = new InMemoryCustomers

application = ApplicationBuilder.with(customers)

test("ensure basket totals are correct when discounts are applied") {
    this.addSomeCustomersWithFullBaskets()
    val result = application.doSomethingAgainstCustomersViaTheApi
    result should be(asExpected)
}
</code></pre>

<p>}
{% endcodeblock %}</p>

<p>But we're saying here that an <code>OracleCustomerTest</code> <em>is a</em> <code>BackdoorCustomers</code>. That doesn't even make sense. There's no strong notion of a <code>BackdoorCustomers</code>; it's not a meaningful <em>noun</em>. Best case scenario, you're upfront about the fact that it's a fixture and rename <code>BackdoorCustomers</code> to <code>CustomersTestFixture</code> but even then, the <em>test</em> is not a <em>fixture</em>, the two are independent. <strong>One is test apparatus that supports the test, the other is the test or experiment itself</strong>.</p>

<p>It's tempting to use traits like this under the pretense of "mixing in" behaviour but you're really inheriting behaviour from something (that in our case) isn't related. You're precluding any type of substitution or inclusion polymorphism. Now arguably, substitution isn't of great value in test code like this but it's still a laudable goal.</p>

<h2>Proper Mixins</h2>

<p>Using inheritance to mixin behaviour contradicts the inheritance vs. composition principle. So just when is a trait with behaviour a genuine mixin? The trick is in <em>how</em> we mix it in. Before, we made the <em>types</em> inherit the trait but we could have mixed the trait into a specific <em>instance</em>.</p>

<p>For example, we can rework our trait to be a self type.</p>

<p>{% codeblock lang:scala %}
trait BackdoorCustomers {</p>

<pre><code>this: Customers =&gt;

def addSomeCustomersWithFullBaskets() = {
    add(RandomCustomer().with(RandomFullBasket()))
    add(RandomDiscountedCustomer().with(RandomFullBasket()))            
}
def addSomeCustomersWithEmptyBaskets() = {
    add(RandomCustomer())
    add(RandomExpiredCustomer())
}
</code></pre>

<p>}
{% endcodeblock %}</p>

<p>It now enforces implementers to also be a sub-type of <code>Customers</code>. This, in turn, forces us to rewrite the test</p>

<p>{% codeblock lang:scala %}
class OracleCustomerTest {</p>

<pre><code>private val customers = new InMemoryCustomers with BackdoorCustomers

private val application = new ApplicationBuilder.with(customers)

test("ensure basket totals are correct when discounts are applied") {
    // ...
}
</code></pre>

<p>}
{% endcodeblock %}</p>

<p>So now our test is not inheriting an orthogonal type. From an object-oriented perspective, it's much cleaner. We use composition to give the test a <code>customers</code> instance but this time, we treat it as two things. The actual type of the thing is;</p>

<p>{% codeblock lang:scala %}
InMemoryCustomers with BackdoorCustomers
{% endcodeblock %}</p>

<p>So all the backdoor methods work along with the API methods but now we can clearer about which is which. For example,</p>

<p>{% codeblock lang:scala %}
customers.addSomeCustomersWithFullBaskets()         // &lt;- a backdoor "fixture" method
application.doSomethingAgainstCustomersViaTheApi    // &lt;- more likely to be the method under test
{% endcodeblock %}</p>

<h2>Conclusion</h2>

<p>Scala is both an object-oriented language and a functional language. So unless your team is entirely behind doing things functionally, you're still going to come across object-oriented thinking and principles. Traits that have behaviour make it awkward because functionally-thinking, you could argue that nouns aren't important and behaviour in traits is just behaviour. So why not extend that behaviour by whatever means (including inheritance)?</p>

<p>Because Scala <em>has objects</em> you can't really just ignore object-oriented semantics and thinking. Not unless, like I say, the entire team buy into functional only code. If that were the case, then reusable behaviour should really be represented as functions on <a href="http://tutorials.jenkov.com/scala/singleton-and-companion-objects.html">Scala singleton objects</a> and not traits. You'd be forced to use composition anyway.</p>

<p>By that logic, it feels like extending traits for re-use in a functional programming context is just lazy. Mixing behaviour "the right way" seems much less contentious.</p>

<h2>Recommended Reading</h2>

<ul>
<li><a href="http://leanpub.com/whatsnewjava8" onClick="trackOutboundLink(this, 'Outbound Links', 'leanpub.com'); return false;">What's New in Java 8</a>, Toby Weston</li>
<li><a href="http://amzn.to/1M0w9jZ" onClick="trackOutboundLink(this, 'Outbound Links', 'amazon.com'); return false;">Learn Scala for Java Developers</a>, Toby Weston</li>
</ul>


<p>&nbsp;
&nbsp;
&nbsp;</p>
]]></content>
  </entry>
  
</feed>
